<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>Goals determine what I going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinyongli.cn/"/>
  <updated>2017-10-28T07:11:01.000Z</updated>
  <id>http://qinyongli.cn/</id>
  
  <author>
    <name>覃永利</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript常用设计模式</title>
    <link href="http://qinyongli.cn/2017/10/28/JavaScript%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://qinyongli.cn/2017/10/28/JavaScript常用设计模式/</id>
    <published>2017-10-28T05:24:23.000Z</published>
    <updated>2017-10-28T07:11:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的JavaScript应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。</p><a id="more"></a><h2 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h2><ul><li>工厂模式</li><li>单体模式</li><li>模块模式</li><li>代理模式</li><li>职责链模式</li><li>命令模式</li><li>模板方法模式</li><li>策略模式</li><li>发布-订阅模式</li><li>中介者模式</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是为了解决多个类似的对象声明的问题，也就是为了解决实例化对象产生的重复问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name, age, sex</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = name;</div><div class="line">    obj.age = age;</div><div class="line">    obj.sex = sex;</div><div class="line">    obj.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> CreatePerson(<span class="string">'xiaowang'</span>, <span class="string">'20'</span>, <span class="string">'boy'</span>);</div><div class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> CreatePerson(<span class="string">'mary'</span>, <span class="string">'18'</span>, <span class="string">'girl'</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//xiaowang</span></div><div class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//may</span></div><div class="line"></div><div class="line"><span class="comment">//返回都是object，无法识别对象的类型，不知道他们是哪个对象的实例。</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person1);<span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person2);<span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></div></pre></td></tr></table></figure><blockquote><p>优点: 能解决多个相似的问题<br>缺点: 不能知道对象识别的问题(对象的类型不知道)</p></blockquote><h3 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h3><p>单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象。如果它可以被实例化，那么它只能被实例化一次。</p><p>对象字面量来创建单体模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Singleton = &#123;</div><div class="line">    attr1: <span class="number">1</span>,</div><div class="line">    attr2: <span class="number">2</span>,</div><div class="line">    method1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attr1;</div><div class="line">    &#125;,</div><div class="line">    method2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attr2;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>单体化模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!instance) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton(name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="keyword">let</span> a = getInstance(<span class="string">'aa'</span>);</div><div class="line"><span class="keyword">let</span> b = getInstance(<span class="string">'bb'</span>);</div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(a.getName());<span class="comment">//aa</span></div><div class="line"><span class="built_in">console</span>.log(b.getName());<span class="comment">//aa</span></div></pre></td></tr></table></figure><p>单体模式的优点:</p><ul><li>可以来用划分命令空间，减少全局变量。</li><li>使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。</li></ul><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Single = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//私有变量</span></div><div class="line">    <span class="keyword">let</span> privateNum = <span class="number">112</span>;</div><div class="line">    <span class="comment">//公有变量</span></div><div class="line">    <span class="keyword">let</span> publicNum = <span class="number">110</span>;</div><div class="line">    <span class="comment">//私有函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//业务逻辑代码</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//公有函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//业务逻辑代码</span></div><div class="line">    &#125;；</div><div class="line">    <span class="comment">//返回一个对象包含公有方法和属性</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        publicNum,</div><div class="line">        publicFunc</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明一个妹子</span></div><div class="line"><span class="keyword">let</span> AGirl = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//声明一个男孩</span></div><div class="line"><span class="keyword">let</span> ABoy = <span class="function"><span class="keyword">function</span> (<span class="params">girl</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.girl = girl;</div><div class="line">    <span class="comment">//送礼物给一个妹子</span></div><div class="line">    <span class="keyword">this</span>.sendMarriageGift = <span class="function"><span class="keyword">function</span> (<span class="params">gift</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'Hi '</span> + <span class="keyword">this</span>.girl.name + <span class="string">', a　boy 送你一个礼物: '</span> + gift;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//代理人</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">Proxy</span> = <span class="function"><span class="keyword">function</span> (<span class="params">girl</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.girl = girl;</div><div class="line">    <span class="keyword">this</span>.sendGift = <span class="function"><span class="keyword">function</span> (<span class="params">gift</span>) </span>&#123;</div><div class="line">        <span class="keyword">new</span> ABoy(girl).sendMarriageGift(gift);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">new</span> AGirl(<span class="string">'漂亮妹子'</span>));</div><div class="line">proxy.sendGift(<span class="string">'结婚戒'</span>);<span class="comment">//Hi 漂亮妹子, a boy 送你一个礼物：　结婚戒</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的JavaScript应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="设计模式" scheme="http://qinyongli.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JS内存</title>
    <link href="http://qinyongli.cn/2017/10/26/%E6%B5%85%E8%B0%88JS%E5%86%85%E5%AD%98/"/>
    <id>http://qinyongli.cn/2017/10/26/浅谈JS内存/</id>
    <published>2017-10-26T11:48:34.000Z</published>
    <updated>2017-10-27T10:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>与前端不同，后端是直面服务器的，所以对性能的要求更高，对内存有更高的要求。如果存在内存泄漏，跟随着时间的流逝，内存泄漏越来越多，程序运行也会越来越慢，最终崩溃。所以要想深入学习node，控制内存的使用是至关重要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;与前端不同，后端是直面服务器的，所以对性能的要求更高，对内存有更高的要求。如果存在内存泄漏，跟随着时间的流逝，内存泄漏越来越多，程序运行也会
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="Memory" scheme="http://qinyongli.cn/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>浅谈curry化</title>
    <link href="http://qinyongli.cn/2017/10/25/%E6%B5%85%E8%B0%88curry%E5%8C%96/"/>
    <id>http://qinyongli.cn/2017/10/25/浅谈curry化/</id>
    <published>2017-10-25T12:12:02.000Z</published>
    <updated>2017-10-28T07:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在函数式编程中我了解到了柯里化，并且觉得它很有意思，所以对它的实现原理进行了探索，其中难点还真不少。</p><a id="more"></a><h2 id="curry化的概念"><a href="#curry化的概念" class="headerlink" title="curry化的概念"></a>curry化的概念</h2><p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><p>你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用</p><h2 id="curry化的实现代码"><a href="#curry化的实现代码" class="headerlink" title="curry化的实现代码"></a>curry化的实现代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sub_curry = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> curry = <span class="function"><span class="keyword">function</span>(<span class="params">fn, len</span>) </span>&#123;</div><div class="line">    len = len || fn.length;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; len) &#123;</div><div class="line">            <span class="keyword">let</span> combined = [fn].concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</div><div class="line">            <span class="keyword">return</span> curry(sub_curry.apply(<span class="keyword">this</span>, combined), len - <span class="built_in">arguments</span>.length);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="curry化使用的哪些知识点"><a href="#curry化使用的哪些知识点" class="headerlink" title="curry化使用的哪些知识点"></a>curry化使用的哪些知识点</h2><ul><li>闭包</li><li>递归</li></ul><h2 id="curry难点解析"><a href="#curry难点解析" class="headerlink" title="curry难点解析"></a>curry难点解析</h2><p>难点是下面这句话的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sub_curry.apply(<span class="keyword">this</span>, combined)</div></pre></td></tr></table></figure><p>这个语句返回一个闭包，并且这个闭包中的fn是前面一个函数。</p><p>附上一张图理解。</p><p><img src="/img/closure.png" alt=""></p><p>这个最终的目的就是把所有的参数传递给fn调用</p><p>附上演示的栗子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> multiply = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a * b * c;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> multiplyCurry = curry(multiply);</div><div class="line"><span class="built_in">console</span>.log(multiplyCurry(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">4</span>));</div><div class="line"><span class="comment">//=&gt;24</span></div></pre></td></tr></table></figure><blockquote><p>另一种实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 另一种简单实现，参数只能从右到左传递</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCurry</span>(<span class="params">func, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arity = func.length;</div><div class="line">    <span class="keyword">var</span> args = args || [];</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">        [].push.apply(_args, args);</div><div class="line">        <span class="comment">// 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span></div><div class="line">        <span class="keyword">if</span> (_args.length &lt; arity) &#123;</div><div class="line">            <span class="keyword">return</span> createCurry.call(<span class="keyword">this</span>, func, _args);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 参数收集完毕，则执行func</span></div><div class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, _args);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在函数式编程中我了解到了柯里化，并且觉得它很有意思，所以对它的实现原理进行了探索，其中难点还真不少。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="FP" scheme="http://qinyongli.cn/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>FP-Pointfree编程指南</title>
    <link href="http://qinyongli.cn/2017/10/25/FP-Pointfree%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>http://qinyongli.cn/2017/10/25/FP-Pointfree编程指南/</id>
    <published>2017-10-25T05:55:32.000Z</published>
    <updated>2017-10-27T05:40:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><a id="more"></a><h2 id="Pointfree"><a href="#Pointfree" class="headerlink" title="Pointfree"></a>Pointfree</h2><h3 id="Pointfree概念"><a href="#Pointfree概念" class="headerlink" title="Pointfree概念"></a>Pointfree概念</h3><p>pointfree 模式指的是，永远不必说出你的数据</p><p>不使用所要处理的值，只合成运算过程。</p><p>example</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> compose = <span class="function"><span class="keyword">function</span> (<span class="params">f, g</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> f(g(x));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</div><div class="line"><span class="keyword">let</span> addOneSquare = compose(square, addOne);</div><div class="line">addOneSquare(<span class="number">2</span>);</div><div class="line"><span class="comment">//=&gt;9</span></div></pre></td></tr></table></figure><p>上面一个栗子，把两个函数组合，然后求值。</p><p>addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。</p><h3 id="Pointfree的本质"><a href="#Pointfree的本质" class="headerlink" title="Pointfree的本质"></a>Pointfree的本质</h3><p>Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。</p><p>example: 读取对象的role属性，不要直接写成obj.role, 而是要把这个操作封装成函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> prop = <span class="function">(<span class="params">p, obj</span>) =&gt;</span> obj[p];</div><div class="line"><span class="keyword">let</span> propRole = curry(prop)(<span class="string">'role'</span>);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="FP" scheme="http://qinyongli.cn/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TCP/IP</title>
    <link href="http://qinyongli.cn/2017/10/21/%E6%B5%85%E8%B0%88TCP-IP/"/>
    <id>http://qinyongli.cn/2017/10/21/浅谈TCP-IP/</id>
    <published>2017-10-21T14:46:48.000Z</published>
    <updated>2017-10-26T16:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>作为一名计算机科学与技术的工科生，了解计算机网络基础是必须的。网络通讯遍布在我们身边，从本博客开始，将启航我在计算机网络上的系列学习。</p><a id="more"></a><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI 模型(开放系统互联模型)是一个由国际标准化组织(ISO)提出概念模型,试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。</p><p>OSI　将计算机网络体系结构划分为七层,每层都可以提供抽象良好的接口。了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。</p><p>七层协议，从下往上</p><ol><li>物理层(网络物理硬件)</li><li>链路层(网络特有的链路接口)</li><li>网络层(IP)</li><li>传输层(TCP/UDP)</li><li>会话层(通信连接/维持会话)</li><li>表示层(加密/解密等)</li><li>应用层(HTTP、SMTP、IMAP等)</li></ol><p>附上三个图促进理解</p><p><img src="/img/OSI1.jpg" alt="OSI图片"></p><p><img src="/img/OSI2.gif" alt="OSI图片"></p><p><img src="/img/OSI3.png" alt="OSI图片"></p><blockquote><p>物理地址，又称网卡的硬件MAC地址(处于数据链路层)负责局域网通讯，IP地址(处于网络层)负责外网通讯</p></blockquote><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>TCP/IP模型也被称作DoD模型(Department of Defense Model)。TCP/IP字面上代表了两个协议：TCP（传输控制协议）和IP（网际协议）。但TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族。从协议分层模型方面来讲，TCP/IP由四个层次组成:网络接口层、网络层、传输层、应用层。TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。</p><blockquote><p>OSI模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去。</p><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>TCP/IP 的设计,是吸取了分层模型的精华思想——封装。每层对上一层提供服务的时候,上一层的数据结构是黑盒,直接作为本层的数据,而不需要关心上一层协议的任何细节</p></blockquote><p>四层模型:</p><p><img src="/img/tipcip&amp;osi.png" alt="tcp/ip四层模型图"></p><p><img src="/img/application.png" alt="tcp/ip图片"></p><p>TCP/IP 分层模型的分层以以太网上传输 UDP 数据包如图所示</p><p><img src="/img/TCPIP.png" alt="tcp/ip图片"></p><p>各层中的协议</p><p><img src="/img/protocol.jpg" alt=""></p><p><img src="/img/tcpipstream.jpg" alt="tcpip通讯流"></p><p>基于tcp的文件传输(ftp－port21)</p><p><img src="/img/datapackage.png" alt=""></p><p>基于TCP和UDP的数据封装及解析示例如下：</p><p><img src="/img/package.jpg" alt=""></p><p>TCP数据包</p><p><img src="/img/tcppackage.jpg" alt=""></p><p>tcp在真正连接前要经过三次握手，断开连接需要经过四次挥手</p><p>TCP三次握手</p><p><img src="/img/threeShake.png" alt=""></p><p>TCP四次挥手</p><ul><li><p>第一次挥手</p><p>  主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p></li><li><p>第二次挥手</p><p>  被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</p></li><li><p>第三次挥手</p><p>  被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了</p></li><li><p>第四次挥手</p><p>  主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p></li></ul><p><img src="/img/waved.jpg" alt="四次挥手图片"></p><h3 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h3><p>以太网数据包(packet)的大小是固定的，最初是1518字节，后来增加到1522字节。其中，1500字节是负载(pyload)，22字节是头部信息(head)。</p><p>IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以IP数据包的负载最多为1480字节。</p><p>IP数据包</p><p><img src="/img/ipPackage.png" alt="paket数据包"></p><blockquote><p>IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。</p></blockquote><p>TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。</p><p>因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。</p><p><img src="/img/packet2.png" alt="packet数据包"></p><p>（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;作为一名计算机科学与技术的工科生，了解计算机网络基础是必须的。网络通讯遍布在我们身边，从本博客开始，将启航我在计算机网络上的系列学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Internet" scheme="http://qinyongli.cn/categories/Internet/"/>
    
    
      <category term="TCP/IP" scheme="http://qinyongli.cn/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MVX</title>
    <link href="http://qinyongli.cn/2017/10/21/%E6%B5%85%E8%B0%88MVX/"/>
    <id>http://qinyongli.cn/2017/10/21/浅谈MVX/</id>
    <published>2017-10-21T05:06:30.000Z</published>
    <updated>2017-10-23T13:34:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>MVC框架最早出现在Java领域，然后慢慢的在前端开发中也被提到，后来又出现了MVP，以及现在最成熟的MVVM</p><a id="more"></a><h2 id="MVX"><a href="#MVX" class="headerlink" title="MVX"></a>MVX</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC（Model-View-Controller）是应用最广泛的软件架构之一，一般MVC分为: Model(模型)、Controller(控制器)和View(视图)。这主要是基于分层的目的，让彼此的职责分开。</p><p>控制器（Controller），一组行为的集合。(业务逻辑)</p><p>模型（Model），数据相关的操作和封装。(数据保存)</p><p>视图（View），视图的渲染。(用户界面)</p><p>View一般通过Controler来和Model进行联系的。Controller是Model和View的协调者，View和Model不直接联系。基本联系都是单项的。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020105.png" alt=""></p><ol><li>View 传送指令到Controler</li><li>Controller 完成业务逻辑，要求 Model 改变状态</li><li>Model 将新的数据发送到　View，用户得到反馈</li></ol><p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020106.png" alt=""></p><p>另一种是直接通过controller接受指令。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020107.png" alt=""></p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP模式将 Controller改名为Persenter,　同时改变了通信方向。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020109.png" alt=""></p><ol><li>各部分之间的通信，都是双向的。</li><li>View 与 Model不发生联系。都通过Persenter传递。</li><li>View 非常薄, 不部署任何业务逻辑，称为”被动视图”，即没有任何主动性，而Persenter非常厚，所有逻辑都部署在那里。</li></ol><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM模式将Persenter改名为ViewModel，基本上与MVP完全一致</p><p><img src="http://image.beekka.com/blog/2015/bg2015020110.png" alt=""></p><p>唯一的区别是，它采用双向绑定(data-binding): View的变动，自动反映在ViewModel，反之亦然。Angular和Vue采用这种模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;MVC框架最早出现在Java领域，然后慢慢的在前端开发中也被提到，后来又出现了MVP，以及现在最成熟的MVVM&lt;/p&gt;
    
    </summary>
    
      <category term="Architecture" scheme="http://qinyongli.cn/categories/Architecture/"/>
    
    
      <category term="MVX" scheme="http://qinyongli.cn/tags/MVX/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Web缓存</title>
    <link href="http://qinyongli.cn/2017/10/19/%E6%B5%85%E8%B0%88Web%E7%BC%93%E5%AD%98/"/>
    <id>http://qinyongli.cn/2017/10/19/浅谈Web缓存/</id>
    <published>2017-10-19T00:48:57.000Z</published>
    <updated>2017-10-27T05:45:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。</p><a id="more"></a><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><ul><li>数据库缓存</li><li>代理服务器缓存</li><li>CDN缓存</li><li>浏览器缓存</li></ul><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>页面的缓存状态是由header决定的，header的参数有四种。</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>其优先级要比Expires高</p><ul><li><p>max-age</p><p>  单位为s，指定设置缓存最大的有效时间，定义时间的长短。当浏览器向服务器发送请求过后，在max-age这段时间里浏览器就不会再向服务器发送请求了。</p><p>  example</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</div><div class="line"><span class="keyword">const</span> host = <span class="string">'127.0.0.1'</span>;</div><div class="line"><span class="keyword">const</span> server = http.createServer();</div><div class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(req.url == <span class="string">'/'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(req.url);</div><div class="line">        fs.readFile(<span class="string">'./index.html'</span>, (err, data) =&gt; &#123;</div><div class="line">            res.statusCode = <span class="number">200</span>;</div><div class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</div><div class="line">            <span class="comment">//设置Cache-Control缓存</span></div><div class="line">            res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=60'</span>);</div><div class="line">            res.end(data);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">server.listen(port, host, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`server serve at http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>  在firefox输入网址后回车，然后在地址栏再次回车。控制台输入的结果如图</p><p>  <img src="/img/cache-control1.png" alt=""></p><p>  一次请求</p><p>  不设置缓存，控制输入的结果如图</p><p>  <img src="/img/cache-control2.png" alt=""></p><p>  两次请求</p></li><li><p>s-maxage</p><p>  单位为s，同max-age，只是用于共享缓存(比如CDN缓存)</p><p>  比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通的缓存，而s-maxage用于代理缓存。<br>  如果存在s-maxage，则会覆盖掉max-age和Expires header</p></li><li><p>public</p><p>  指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定public还是private，则默认为public</p></li><li><p>private</p><p>  响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private</p></li><li><p>no-cache</p><p>  指定不缓存响应</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</div></pre></td></tr></table></figure><p>  设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间</p></li><li><p>no-store</p><p>  绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存，每次请求资源都要从服务器重新获取</p></li></ul><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>单位为毫秒ms，缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">res.setHeader(<span class="string">'Expires'</span>, <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">60</span> * <span class="number">2</span> * <span class="number">1000</span>).toUTCString()&#125;</span>`</span>);</div><div class="line"><span class="comment">//设置过期时间为两分钟后</span></div></pre></td></tr></table></figure><p>在控制台上输出的结果如cache-control的一样</p><h4 id="Last-modified"><a href="#Last-modified" class="headerlink" title="Last-modified"></a>Last-modified</h4><p>服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。&lt;/p&gt;
    
    </summary>
    
      <category term="Performance" scheme="http://qinyongli.cn/categories/Performance/"/>
    
    
      <category term="cache" scheme="http://qinyongli.cn/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>新的hexo</title>
    <link href="http://qinyongli.cn/2017/10/18/%E6%96%B0%E7%9A%84hexo/"/>
    <id>http://qinyongli.cn/2017/10/18/新的hexo/</id>
    <published>2017-10-18T13:40:52.000Z</published>
    <updated>2017-10-27T05:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新的博客"><a href="#新的博客" class="headerlink" title="新的博客"></a>新的博客</h1><p>哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，希望能和大家一起分享自己的技术心得，我们一起学习成长。一步一步提高自己的技能点，早日实现自己的技术之梦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新的博客&quot;&gt;&lt;a href=&quot;#新的博客&quot; class=&quot;headerlink&quot; title=&quot;新的博客&quot;&gt;&lt;/a&gt;新的博客&lt;/h1&gt;&lt;p&gt;哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，
      
    
    </summary>
    
      <category term="life" scheme="http://qinyongli.cn/categories/life/"/>
    
    
      <category term="hexo" scheme="http://qinyongli.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
