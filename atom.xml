<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>Goals determine what I going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinyongli.cn/"/>
  <updated>2017-10-22T14:16:04.873Z</updated>
  <id>http://qinyongli.cn/</id>
  
  <author>
    <name>覃永利</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈TCP/IP HTTP HTTPS HTTP2</title>
    <link href="http://qinyongli.cn/2017/10/21/%E6%B5%85%E8%B0%88TCP-IP-HTTP-HTTPS-HTTP2/"/>
    <id>http://qinyongli.cn/2017/10/21/浅谈TCP-IP-HTTP-HTTPS-HTTP2/</id>
    <published>2017-10-21T14:46:48.000Z</published>
    <updated>2017-10-22T14:16:04.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>作为一名计算机科学与技术的工科生，了解网络基础是必须的。只要涉及到网络通讯、B/S交互，必会有网络协议。从本博客开始，开启我在网络协议上的系统学习。</p><a id="more"></a><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI 模型(Open System Interconnection model)是一个由国际标准化组织提出概念模型,试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。OSI是传统的开放式系统互连参考模型，是一种通信协议的7层抽象的参考模型，其中每一层执行某一特定任务。该模型的目的是使各种硬件在相同的层次上相互通信。</p><p>它将计算机网络体系结构划分为七层,每层都可以提供抽象良好的接口。了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。</p><p>七层协议，从下往上</p><ol><li>物理层(网络物理硬件)</li><li>链路层(网络特有的链路接口)</li><li>网络层(IP)</li><li>传输层(TCP/UDP)</li><li>会话层(通信连接/维持会话)</li><li>表示层(加密/解密等)</li><li>应用层(HTTP、SMTP、IMAP等)</li></ol><p>附上三个图促进理解</p><p><img src="/img/OSI1.jpg" alt="OSI图片"></p><p><img src="/img/OSI2.gif" alt="OSI图片"></p><p><img src="/img/OSI3.png" alt="OSI图片"></p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>百度百科定义：TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在因特网协议族(Internet protocol suite)中，TCP层是位于IP层之上，应用层之下的中间层。</p><p>百度百科定义: 网络之间互连的协议外文是Internet Protocol的外语缩写，中文缩写为“网协”。缩写为IP。</p><p>百度百科定义：TCP/IP模型也被称作DoD模型(Department of Defense Model)。TCP/IP字面上代表了两个协议：TCP（传输控制协议）和IP（网际协议）。但TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族。从协议分层模型方面来讲，TCP/IP由四个层次组成:网络接口层、网络层、传输层、应用层。TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。</p><p>OSI模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去。TCP/IP没有照搬OSI模型,也没有 一个公认的TCP/IP层级模型,一般划分为三层到五层模型来描述TCP/IP协议。</p><ul><li>在此描述用一个通用的四层模型来描述,每一层都和 OSI 模型有较强的相关性但是又可能会有交叉</li><li>TCP/IP 的设计,是吸取了分层模型的精华思想——封装。每层对上一层提供服务的时候,上一层的数据结构是黑盒,直接作为本层的数据,而不需要关心上一层协议的任何细节</li></ul><p><img src="/img/tipcip&amp;osi.png" alt="tcp/ip四层模型图"></p><p>TCP/IP 分层模型的分层以以太网上传输 UDP 数据包如图所示</p><p><img src="/img/TCPIP.png" alt="tcp/ip图片"></p><p><img src="/img/application.png" alt="tcp/ip图片"></p><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><p>以太网数据包(packet)的大小是固定的，最初是1518字节，后来增加到1522字节。其中，1500字节是负载(pyload)，22字节是头部信息(head)。</p><p>IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以IP数据包的负载最多为1480字节。</p><p><img src="/img/packet.png" alt="paket数据包"></p><p>（图片说明：IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。）</p><p>TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。</p><p>因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。</p><p><img src="/img/packet2.png" alt="packet数据包"></p><p>（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）</p><p>TCP/IP通信数据流</p><p><img src="/img/tcpipstream.jpg" alt="tcpip通讯流"></p><p>建立连接(三次握手)</p><p>握手过程中使用了TCP的标志：SYN和ACK。<br>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</p><p><img src="/img/threeshakehands.gif" alt="三次握手"></p><p><img src="/img/threeshakehands.png" alt="三次握手"></p><p>中断连接(四次挥手)</p><ul><li><p>第一次挥手</p><p>  主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p></li><li><p>第二次挥手</p><p>  被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</p></li><li><p>第三次挥手</p><p>  被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了</p></li><li><p>第四次挥手</p><p>  主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p></li></ul><p><img src="/img/waved.jpg" alt="四次挥手图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;作为一名计算机科学与技术的工科生，了解网络基础是必须的。只要涉及到网络通讯、B/S交互，必会有网络协议。从本博客开始，开启我在网络协议上的系统学习。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络知识" scheme="http://qinyongli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="协议" scheme="http://qinyongli.cn/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Web缓存</title>
    <link href="http://qinyongli.cn/2017/10/19/%E6%B5%85%E8%B0%88Web%E7%BC%93%E5%AD%98/"/>
    <id>http://qinyongli.cn/2017/10/19/浅谈Web缓存/</id>
    <published>2017-10-19T00:48:57.000Z</published>
    <updated>2017-10-22T14:14:59.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。</p><a id="more"></a><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><ul><li>数据库缓存</li><li>代理服务器缓存</li><li>CDN缓存</li><li>浏览器缓存</li></ul><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>页面的缓存状态是由header决定的，header的参数有四种。</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>其优先级要比Expires高</p><ul><li><p>max-age</p><p>  单位为s，指定设置缓存最大的有效时间，定义时间的长短。当浏览器向服务器发送请求过后，在max-age这段时间里浏览器就不会再向服务器发送请求了。</p><p>  example</p><pre><code>const http = require(&apos;http&apos;);const fs = require(&apos;fs&apos;);const port = 3000;const host = &apos;127.0.0.1&apos;;const server = http.createServer();server.on(&apos;request&apos;, (req, res) =&gt; {    if(req.url == &apos;/&apos;) {        console.log(req.url);        fs.readFile(&apos;./index.html&apos;, (err, data) =&gt; {            res.statusCode = 200;            res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);            //设置Cache-Control缓存            res.setHeader(&apos;Cache-Control&apos;, &apos;max-age=60&apos;);            res.end(data);        });    }});server.listen(port, host, () =&gt; {    console.log(`server serve at http://${host}:${port}`);});</code></pre><p>  在firefox输入网址后回车，然后在地址栏再次回车。控制台输入的结果如图</p><p>  <img src="/img/cache-control1.png" alt=""></p><p>  一次请求</p><p>  不设置缓存，控制输入的结果如图</p><p>  <img src="/img/cache-control2.png" alt=""></p><p>  两次请求</p></li><li><p>s-maxage</p><p>  单位为s，同max-age，只是用于共享缓存(比如CDN缓存)</p><p>  比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通的缓存，而s-maxage用于代理缓存。<br>  如果存在s-maxage，则会覆盖掉max-age和Expires header</p></li><li><p>public</p><p>  指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定public还是private，则默认为public</p><p>  <img src="http://mmbiz.qpic.cn/mmbiz/zPh0erYjkib2D4WtKTwFjia6LOoTP8ZGh8Cg1zJUEs2bxE7RwfeibUW9dn8YFEzrgRUn5ZPJxghtZtoTicxnYZNVWQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p></li><li><p>private</p><p>  响应只作为私有的缓存（见下图），不能在用户间共享。如果要求HTTP认证，响应会自动设置为private</p><p>  <img src="http://mmbiz.qpic.cn/mmbiz/zPh0erYjkib2D4WtKTwFjia6LOoTP8ZGh8OL46IMZjco3MibibBb1ZHQkLibIhpryUtssj6hwvAngxMaiaSqNjBUtjrA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p></li><li><p>no-cache</p><p>  指定不缓存响应</p><pre><code>res.setHeader(&apos;Cache-Control&apos;, &apos;no-cache&apos;);</code></pre><p>  <img src="http://mmbiz.qpic.cn/mmbiz/zPh0erYjkib2D4WtKTwFjia6LOoTP8ZGh8HmoFicWNkZ8GO2O5p5zFVmHE9QFVeyuAy7AdDL8T6iavSxqpx16fG6JA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>  设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间</p></li><li><p>no-store</p><p>  绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存，每次请求资源都要从服务器重新获取</p></li></ul><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>单位为毫秒ms，缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><pre><code>res.setHeader(&apos;Expires&apos;, `${new Date(Date.now() + 60 * 2 * 1000).toUTCString()}`);//设置过期时间为两分钟后</code></pre><p>在控制台上输出的结果如cache-control的一样</p><h4 id="Last-modified"><a href="#Last-modified" class="headerlink" title="Last-modified"></a>Last-modified</h4><p>服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="http://qinyongli.cn/categories/Web/"/>
    
    
      <category term="Web缓存" scheme="http://qinyongli.cn/tags/Web%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>新的hexo</title>
    <link href="http://qinyongli.cn/2017/10/18/%E6%96%B0%E7%9A%84hexo/"/>
    <id>http://qinyongli.cn/2017/10/18/新的hexo/</id>
    <published>2017-10-18T13:40:52.000Z</published>
    <updated>2017-10-18T13:47:43.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新的博客"><a href="#新的博客" class="headerlink" title="新的博客"></a>新的博客</h1><p>哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，希望能和大家一起分享自己的技术心得，我们一起学习成长。一步一步提高自己的技能点，早日实现自己的技术之梦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新的博客&quot;&gt;&lt;a href=&quot;#新的博客&quot; class=&quot;headerlink&quot; title=&quot;新的博客&quot;&gt;&lt;/a&gt;新的博客&lt;/h1&gt;&lt;p&gt;哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，
      
    
    </summary>
    
      <category term="blog" scheme="http://qinyongli.cn/categories/blog/"/>
    
    
      <category term="hexo" scheme="http://qinyongli.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
