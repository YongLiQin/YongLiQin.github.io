<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>Goals determine what I going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qinyongli.cn/"/>
  <updated>2017-11-05T07:58:29.000Z</updated>
  <id>http://qinyongli.cn/</id>
  
  <author>
    <name>覃永利</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈Cookie、Session、JWTS</title>
    <link href="http://qinyongli.cn/2017/11/03/%E6%B5%85%E8%B0%88Cookie%E3%80%81Session%E3%80%81JWTS/"/>
    <id>http://qinyongli.cn/2017/11/03/浅谈Cookie、Session、JWTS/</id>
    <published>2017-11-03T14:35:10.000Z</published>
    <updated>2017-11-05T07:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>HTTP是一个无状态的协议，现实中的业务却是需要一定的状态的，否则无法区分用户之间的身份。</p><a id="more"></a><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="初识Cookie"><a href="#初识Cookie" class="headerlink" title="初识Cookie"></a>初识Cookie</h3><p>HTTP是无状态的，如何标识和认证一个用户，最早的方案就是Cookie（曲奇饼）。它能记录服务器与客户端之间的状态，最早的用处就是用来判断用户是否第一次访问网站。在1997年形成规范RFC 2109，目前最新的规范为RFC 6065，它是一个由浏览器和服务器共同协作实现的规范。</p><p>Cookie的处理分为如下几步。</p><ul><li>服务器向客户端发送Cookie。</li><li>浏览器将Cookie保存。</li><li>之后每次浏览器都将会将Cookie发向服务器端。</li></ul><p>客户端发送的Cookie在请求报文的Cookie字段中。</p><p>HTTP_Parser会将所有的报文字段解析到req.headers，那么Cookie就是req.headers.cookie。根据规范中的定义，Cookie值的格式是key-value; key2=value2形式，如果我们需要Cookie，解析它也十分容易。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> parseCookie = <span class="function"><span class="keyword">function</span> (<span class="params">cookie</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> cookies = &#123;&#125;;</div><div class="line">    <span class="keyword">if</span>(!cookie) &#123;</div><div class="line">        <span class="keyword">return</span> cookies;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> list = cookie.split(<span class="string">';'</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">        <span class="keyword">let</span> pair = list[i].split(<span class="string">'='</span>);</div><div class="line">        cookies[pair[<span class="number">0</span>].trim()] = pair[<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cookies;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在业务逻辑代码执行之前，我们将其挂载在req对象上，让业务代码可以直接访问，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    req.cookies = parseCookie(req.headers.cookie);</div><div class="line">    handle(req, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们的业务代码就可以进行判断处理了，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    <span class="keyword">if</span>(req.cookies.isVisit) &#123;</div><div class="line">        res.end(<span class="string">'欢迎第一次来到动物园'</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//TODO</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: name=value; Path=<span class="string">'/'</span>;Expires=Sun, <span class="number">23</span>-Apr<span class="number">-23</span> <span class="number">09</span>:<span class="number">01</span>:<span class="number">35</span> GMT; Domain=.domain.com;</div></pre></td></tr></table></figure><p>其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项。</p><ul><li>path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。</li><li>Expires和Max-Age是用来告知浏览器这个Cookie何时过期，如果不设置该选项，在关闭浏览器时将会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。</li><li>HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求过程中，依然会发送这个Cookie到服务器端。</li><li>Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行通话验证，如果是HTTP连接则不会传递该消息，所以很难被窃听到。</li></ul><p>知道Cookie在报文头中的具体格式后，下面我们将Cookie序列化成符合规范的字符串，相关代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> serialize = <span class="function"><span class="keyword">function</span> (<span class="params">name, val, opt</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> pairs = [name + <span class="string">'='</span> + encode(val)];</div><div class="line">    opt = opt || &#123;&#125;;</div><div class="line">    <span class="keyword">if</span>(opt.maxAge) pairs.push(<span class="string">`Max-Age=<span class="subst">$&#123;opt.maxAge&#125;</span>`</span>);</div><div class="line">    <span class="keyword">if</span>(opt.domain) pairs.push(<span class="string">`Domain=<span class="subst">$&#123;opt.domain&#125;</span>`</span>);</div><div class="line">    <span class="keyword">if</span>(opt.path) pairs.push(<span class="string">`Path=<span class="subst">$&#123;opt.path&#125;</span>`</span>);</div><div class="line">    <span class="keyword">if</span>(opt.expires) pairs.push(<span class="string">`Expires=<span class="subst">$&#123;opt.expires.toUTCString()&#125;</span>`</span>);</div><div class="line">    <span class="keyword">if</span>(opt.httpOnly) pairs.push(<span class="string">`HttpOnly`</span>);</div><div class="line">    <span class="keyword">if</span>(opt.secure) pairs.push(<span class="string">`Secure`</span>);</div><div class="line">    <span class="keyword">return</span> pairs.join(<span class="string">`; `</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>判断用户的状态，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!req.cookies.isVisit) &#123;</div><div class="line">        req.setHeader(<span class="string">`Set-Cookie, <span class="subst">$&#123;serialize(<span class="string">'isVisit'</span>, <span class="number">1</span>)&#125;</span>`</span>);</div><div class="line">        res.writeHead(<span class="number">200</span>);</div><div class="line">        res.end(<span class="string">'欢迎第一次来动物园'</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        res.writeHad(<span class="number">200</span>);</div><div class="line">        res.end(<span class="string">`动物园再次欢迎你`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>客户端收到这个带Set-Cookie的响应后，在之后的请求时会在Cookie字段中带上这个值。</p><p>Set-Cookie是较少的，在报头中可能存在多字段。为此res.setHeader的第二个参数可以是一个数组，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Set</span>-Cookie: foo=bar; Path=<span class="regexp">/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com</span></div><div class="line"><span class="regexp">Set-Cookie: foo=val; Path=/</span>; Expires=Sun, <span class="number">23</span>-Apr<span class="number">-23</span> <span class="number">09</span>:<span class="number">01</span>:<span class="number">35</span> GMT; Domain=.domain.com</div></pre></td></tr></table></figure><h3 id="Cookie的性能影响"><a href="#Cookie的性能影响" class="headerlink" title="Cookie的性能影响"></a>Cookie的性能影响</h3><p>由于Cookie的实现机制，一旦服务器端向客户端发送了设置Cookie的意图，除非Cookie过期，否则客户端每次请求都会发送这些Cookie到服务器端，一旦设置的Cookie过多，将会导致报头较大。大多数的Cookie并不需要每次都用上，因为这会造成宽带的部分浪费。在YSlow的性能优化规则中有这么一条:</p><ul><li>减小Cookie的大小</li><li>为静态组件使用不同的域名</li><li>减少DNS查询</li></ul><blockquote><p>如果在域名的根节点设置Cookie，几乎所有的子路径下的请求都会带上这些Cookie</p></blockquote><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Cookie并非完美，前文提及的体积过大就是一个显著的问题，最为严重的问题是Cookie可以在前后端进行修改，因此数据就极容易被篡改和伪造。</p><p>Session的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。</p><p>将每个客户端和服务器中的数据一一对应起来的两种实现方式。</p><h4 id="基于Cookie来实现用户和数据的映射。-口令sessionid"><a href="#基于Cookie来实现用户和数据的映射。-口令sessionid" class="headerlink" title="基于Cookie来实现用户和数据的映射。(口令sessionid)"></a>基于Cookie来实现用户和数据的映射。(口令sessionid)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sessions = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> key = <span class="string">'session_id'</span>;</div><div class="line"><span class="keyword">let</span> EXPIRES = <span class="number">20</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> session = &#123;&#125;;</div><div class="line">    session.id = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + <span class="built_in">Math</span>.random();</div><div class="line">    session.cookie = &#123;</div><div class="line">        expires: (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES</div><div class="line">    &#125;;</div><div class="line">    sessions[session.id] = session;</div><div class="line">    <span class="keyword">return</span> session;</div><div class="line">&#125; ;</div></pre></td></tr></table></figure><p>每一次请求到来时，检查Cookie中的口令与服务器端的数据，如果过期，就重新生成，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> id = req.cookies[key];</div><div class="line">    <span class="keyword">if</span>(!id) &#123;</div><div class="line">        req.session = generate();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">let</span> session = sessions[id];</div><div class="line">        <span class="keyword">if</span>(session) &#123;</div><div class="line">            <span class="keyword">if</span>(session.cookie.expires &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() ) &#123;</div><div class="line">                <span class="comment">//更新超时时间</span></div><div class="line">                session.cookie.expires = <span class="built_in">Date</span>.now() + EXPIRES;</div><div class="line">                req.session = session;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//如果超时了，删除旧数据，并重新生成。</span></div><div class="line">                <span class="keyword">delete</span> sessions[id];</div><div class="line">                req.session = gennerate();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//如果session过期或口令不对，重新生成session</span></div><div class="line">            res.session = generate();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    handle(req, res);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>把重新生成的Session响应给客户。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> writeHead = res.writeHead;</div><div class="line">res.writeHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> cookies = res.getHeader(<span class="string">'Set-Cookie'</span>);</div><div class="line">    <span class="keyword">let</span> session = serialize(key, req.session.id);</div><div class="line">    cookies = <span class="built_in">Array</span>.isArray(cookies) ? cookies.concat(session) : [cookies, session];</div><div class="line">    res.setHeader(<span class="string">'Set-Cookie'</span>, cookies);</div><div class="line">    <span class="keyword">return</span> writeHead.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>Sesion依赖于Cookie实现，是目前大多数Web应用的方案。</p><h4 id="通过查询字符串来实现浏览器和服务器端数据对应"><a href="#通过查询字符串来实现浏览器和服务器端数据对应" class="headerlink" title="通过查询字符串来实现浏览器和服务器端数据对应"></a>通过查询字符串来实现浏览器和服务器端数据对应</h4><p>略…</p><h3 id="Session问题"><a href="#Session问题" class="headerlink" title="Session问题"></a>Session问题</h3><h4 id="Session与内存"><a href="#Session与内存" class="headerlink" title="Session与内存"></a>Session与内存</h4><h4 id="Session与安全"><a href="#Session与安全" class="headerlink" title="Session与安全"></a>Session与安全</h4><p>口令保存在客户端，口令可能会被盗取，口令可能会被伪造。</p><p>对口令通过私钥加密进行签名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> val + <span class="string">'.'</span> + crypto</div><div class="line">        .createHmac(<span class="string">'sha256'</span>, secret)</div><div class="line">        .update(val)</div><div class="line">        .digest(<span class="string">'base64'</span>)</div><div class="line">        .replace(<span class="regexp">/\=+$/</span>, <span class="string">''</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>在响应时，设置session值到Cookie中，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> val = sign(req.sessionID, secret);</div><div class="line">res.setHeader(<span class="string">'Set-Cookie'</span>, cookie.serialize(key, val));</div></pre></td></tr></table></figure><p>接收请求时，检查签名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> unsign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> str = val.slice(<span class="number">0</span>, val.lastIndex(<span class="string">'.'</span>));</div><div class="line">    <span class="keyword">return</span> sign(str, secret) == val ? str : <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="JSON-Web-Token-JWT"><a href="#JSON-Web-Token-JWT" class="headerlink" title="JSON Web Token (JWT)"></a>JSON Web Token (JWT)</h3><p><a href="https://jwt.io" target="_blank" rel="external">jwt</a>官方介绍</p><p>JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA.</p><h4 id="jwt的组成"><a href="#jwt的组成" class="headerlink" title="jwt的组成"></a>jwt的组成</h4><p>一个jwt实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><h4 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部(Header)"></a>头部(Header)</h4><p>The header typically consists of two parts: the type of the token, which is JWT, and the hashing algorithm being used, such as HMAC SHA256 or RSA.</p><p>用于描述关于该JWT的最基本信息，类型与签名所用的算法。</p><p>for example</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</div><div class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Then, this JSON is Base64Url encoded to form the first part of the JWT.</p><h4 id="载荷-Payload"><a href="#载荷-Payload" class="headerlink" title="载荷(Payload)"></a>载荷(Payload)</h4><p>The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional metadata. There are three types of claims: reserved, public, and private claims.</p><ul><li>Reserved claims: These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others.</li><li>Public claims: These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace.</li><li>These are the custom claims created to share information between parties that agree on using them.</li></ul><p>An example of payload could be:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</div><div class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</div><div class="line">  <span class="string">"admin"</span>: <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>The payload is then Base64Url encoded to form the second part of the JSON Web Token</p><h4 id="签名-signature"><a href="#签名-signature" class="headerlink" title="签名(signature)"></a>签名(signature)</h4><p>To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.</p><p>For example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HMACSHA256(</div><div class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</div><div class="line">  base64UrlEncode(payload),</div><div class="line">  secret)</div></pre></td></tr></table></figure><p>The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn’t changed along the way.</p><h4 id="放它们到一起"><a href="#放它们到一起" class="headerlink" title="放它们到一起"></a>放它们到一起</h4><p>The output is three Base64 strings separated by dots that can be easily passed in HTML and HTTP environments.</p><p>The following shows a JWT that has the previous header and payload encoded, and it is signed with a secret. </p><p><img src="https://cdn.auth0.com/content/jwt/encoded-jwt3.png" alt=""></p><h4 id="JWT是怎么样工作的"><a href="#JWT是怎么样工作的" class="headerlink" title="JWT是怎么样工作的"></a>JWT是怎么样工作的</h4><p><img src="https://cdn.auth0.com/content/jwt/jwt-diagram.png" alt=""></p><h4 id="JWT与Session的区别"><a href="#JWT与Session的区别" class="headerlink" title="JWT与Session的区别"></a>JWT与Session的区别</h4><p><img src="/img/session.png" alt=""></p><p><img src="/img/token.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;HTTP是一个无状态的协议，现实中的业务却是需要一定的状态的，否则无法区分用户之间的身份。&lt;/p&gt;
    
    </summary>
    
      <category term="NODEJS" scheme="http://qinyongli.cn/categories/NODEJS/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈Node-WebSocket</title>
    <link href="http://qinyongli.cn/2017/11/03/%E6%B5%85%E8%B0%88Node-WebSocket/"/>
    <id>http://qinyongli.cn/2017/11/03/浅谈Node-WebSocket/</id>
    <published>2017-11-03T03:12:45.000Z</published>
    <updated>2017-11-03T13:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>WebSocket在客户端与服务器端的通讯中占有重要的地位，基于WebSocket客户端可以随时向服务器端发送数据，服务器也可以随时向客户端发送数据。多人在线聊天室就是基于WebSocket构建的。</p><a id="more"></a><h2 id="构建WebSocket服务"><a href="#构建WebSocket服务" class="headerlink" title="构建WebSocket服务"></a>构建WebSocket服务</h2><p>Websocket与Node之间的配合堪称完成完美，其理由有两条:</p><ul><li>WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。</li><li>WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量客户端保持高并发连接。</li></ul><h3 id="WebSocket的介绍"><a href="#WebSocket的介绍" class="headerlink" title="WebSocket的介绍"></a>WebSocket的介绍</h3><ul><li>客户端与服务器端只建立一个TCP连接，可以使用更少的连接。</li><li>WebSocket服务器可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。</li><li>有更轻量级的协议头，减少数据传送量。</li></ul><p>在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询(long-polling)或iframe流。</p><p>WebSocket与HTTP相比，它更接近于传输层协议，它并没有在HTTP的基础上模拟服务器端的推送，而是在TCP上定义独立的协议。让人迷惑的部分在于它的握手部分是由HTTP完成的，使人觉得它可能是基于HTTP实现的。</p><p>WebSocket协议主要分为两个部分: 握手和数据传输。</p><h3 id="WebSocket握手"><a href="#WebSocket握手" class="headerlink" title="WebSocket握手"></a>WebSocket握手</h3><p>客户端建立连接时，通过HTTP发起请求报文，如下所示:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: server.exaple.com</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGh1IHNhbXBsZSBub25jZQ==</div><div class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat，superchat</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure><p>与普通的HTTP请求协议略有区别的部分在于如下这些协议头:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div></pre></td></tr></table></figure><p>上述两个字段表示请求服务器端升级协议头为WebSocket。其中Sec-WebSocket-Key用于安全校验: </p><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGh1IHNhbXBsZSBub25jZQ==</div></pre></td></tr></table></figure><p>Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与与字符串258EAFA5-E914-47DA-95CA-C5ABoDC85B11相连，形成字符串dGh1IHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5ABoDC85B11，然后通过sha1安全散列算法计算出结果后，在进行Base64编码，最后返回给客户端。这个算法如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"><span class="keyword">const</span> val = crypto.crateHash(<span class="string">'sha1'</span>).update(key).digest(<span class="string">'base64'</span>);</div></pre></td></tr></table></figure><p>另外，下面两个字段指定子协议和版本号: </p><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat，superchat</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure><p>服务器端在处理完请求后，响应如下报文</p><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</div><div class="line"><span class="attribute">Upgrade</span>: webSocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTaxaQ9kYGzzhZRbK+xOo=</div><div class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</div></pre></td></tr></table></figure><p>上面的报文告之客户端正在更换协议，更新应用层协议为WebSocket协议，并在当前的套接字连接上应用新协议。剩余字段分别表示服务器端基于Sec-WebSocket-Key生成的字符串和选中的子协议。客户端将会校验Sec-WebSocket-Accept的值，如果成功，将开始接下来的数据传输。</p><h4 id="Node构建WebSocket客户端"><a href="#Node构建WebSocket客户端" class="headerlink" title="Node构建WebSocket客户端"></a>Node构建WebSocket客户端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseUrl</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> hostportpath = url.split(<span class="string">'//'</span>)[<span class="number">1</span>];</div><div class="line">    <span class="keyword">let</span> host = hostportpath.split(<span class="string">':'</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">let</span> portpath = hostportpath.split(<span class="string">':'</span>)[<span class="number">1</span>];</div><div class="line">    <span class="keyword">let</span> port = portpath.split(<span class="string">'/'</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        port,</div><div class="line">        host</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> WebSocket = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="comment">//伪代码，解析ws://127.0.0.1:12010/updates，用于请求</span></div><div class="line">    <span class="keyword">this</span>.options = parseUrl(url);</div><div class="line">    <span class="keyword">this</span>.connect();</div><div class="line">&#125;;</div><div class="line">WebSocket.prototype.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//TODO</span></div><div class="line">&#125;;</div><div class="line">WebSocket.prototype.setSocket = <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.socket = socket;</div><div class="line">&#125;;</div><div class="line">WebSocket.prototype.connect = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> key = <span class="keyword">new</span> Buffer(<span class="keyword">this</span>.options.protocolVersion + <span class="string">'-'</span> + <span class="built_in">Date</span>.now()).toString(<span class="string">'base64'</span>);</div><div class="line">    <span class="keyword">let</span> shasum = crypto.createHash(<span class="string">'sha1'</span>);</div><div class="line">    <span class="keyword">let</span> expected = shasum.update(key + <span class="string">'258EAFA5-E914-47DA-95CA-C5ABoDC85B11'</span>).digest(<span class="string">'base64'</span>);</div><div class="line">    <span class="keyword">let</span> options = &#123;</div><div class="line">        port: <span class="keyword">this</span>.options.port,</div><div class="line">        host: <span class="keyword">this</span>.options.hostname,</div><div class="line">        headers: &#123;</div><div class="line">            <span class="string">'Connection'</span>: <span class="string">'Upgrade'</span>,</div><div class="line">            <span class="string">'Upgrade'</span>: <span class="string">'websocket'</span>,</div><div class="line">            <span class="string">'Sec-WebSocket-Key'</span>: key</div><div class="line">            <span class="string">'Sec-WebSocket-Version'</span>: <span class="number">13</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> req = http.request(options, (res, socket, upgradeHead) =&gt; &#123;</div><div class="line">        <span class="keyword">this</span>.setSocket(socket);</div><div class="line">        <span class="keyword">this</span>.onopen();</div><div class="line">    &#125;);</div><div class="line">    req.end();</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="Node构建WebSocket服务器"><a href="#Node构建WebSocket服务器" class="headerlink" title="Node构建WebSocket服务器"></a>Node构建WebSocket服务器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"><span class="keyword">const</span> server = http.createServer();</div><div class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</div><div class="line">    res.end(<span class="string">'Hello World'</span>);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">4000</span>, <span class="string">'localhost'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'http://localhost:4000'</span>);</div><div class="line">&#125;);</div><div class="line">server.on(<span class="string">'upgrade'</span>, (req, socket, upgradeHead) =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> head = <span class="keyword">new</span> Buffer(upgradeHead.length);</div><div class="line">    upgradeHead.copy(head);</div><div class="line">    <span class="keyword">let</span> key = req.headers[<span class="string">'sec-websocket-key'</span>];</div><div class="line">    <span class="keyword">let</span> shasum = crypto.createHash(<span class="string">'sha1'</span>);</div><div class="line">    key = shasum.update(key + <span class="string">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span>).digest(<span class="string">'base64'</span>);</div><div class="line">    <span class="keyword">let</span> headers = [</div><div class="line">        <span class="string">'HTTP/1.1 101 Switching Protocols'</span>,</div><div class="line">        <span class="string">'Upgrade: websocket'</span>,</div><div class="line">        <span class="string">'Connection: Upgrade'</span>,</div><div class="line">        <span class="string">'Sec-WebSocket-Accept: '</span> + key,</div><div class="line">    ];</div><div class="line">    </div><div class="line">    socket.setNoDelay(<span class="literal">true</span>);</div><div class="line">    socket.write(headers.concat(<span class="string">''</span>, <span class="string">''</span>).join(<span class="string">'\r\n'</span>));</div><div class="line">    <span class="keyword">let</span> data = <span class="string">''</span>;</div><div class="line">    socket.on(<span class="string">'data'</span>, chunk =&gt; &#123;</div><div class="line">        data += chunk;</div><div class="line">    &#125;);</div><div class="line">    socket.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">        <span class="built_in">console</span>.log(data);</div><div class="line">        socket.write(<span class="string">'nodejs'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="WebSocket数据传输"><a href="#WebSocket数据传输" class="headerlink" title="WebSocket数据传输"></a>WebSocket数据传输</h3><p>在握手顺利完成后，当前连接将不再进行HTTP的交互，而是开始WebSocket的数据帧协议，实现客户端与服务器端的数据交换。下图为协议升级过程示意图。</p><p><img src="/img/websocketprotocol.png" alt=""></p><p>为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧(比如中间拦截破坏)，连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;WebSocket在客户端与服务器端的通讯中占有重要的地位，基于WebSocket客户端可以随时向服务器端发送数据，服务器也可以随时向客户端发送数据。多人在线聊天室就是基于WebSocket构建的。&lt;/p&gt;
    
    </summary>
    
      <category term="NODEJS" scheme="http://qinyongli.cn/categories/NODEJS/"/>
    
    
      <category term="WebSocket" scheme="http://qinyongli.cn/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>浅谈HTTP</title>
    <link href="http://qinyongli.cn/2017/10/30/%E6%B5%85%E8%B0%88HTTP/"/>
    <id>http://qinyongli.cn/2017/10/30/浅谈HTTP/</id>
    <published>2017-10-30T15:24:46.000Z</published>
    <updated>2017-11-03T13:37:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>作为一个WEB开发者，了解一些常用的协议是必须的，本编将总结自己在协议方面的学习。</p><a id="more"></a><h2 id="WEB始祖HTTP"><a href="#WEB始祖HTTP" class="headerlink" title="WEB始祖HTTP"></a>WEB始祖HTTP</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如TCP建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。</p><p>HTTP得以发展是W3C和IETF两个组织和作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。</p><h2 id="HTTP的基本优化"><a href="#HTTP的基本优化" class="headerlink" title="HTTP的基本优化"></a>HTTP的基本优化</h2><p>影响一个HTTP网络请求的因素主要有两个: 宽带和延迟。</p><p>宽带: 如果说我们还停留在拨号上网的阶段，宽带可能成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得宽带得到极大的提升，我们就不再会担心有宽带而影响网速了。</p><p>延迟: </p><ul><li>浏览器阻塞(HOL blocking):　浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有4个连接(这个根据浏览器内核不同可能会有所差异)，超过浏览器最大连接限制，后续请求就会被阻塞。</li><li>DNS查询(DNS Lookup): 浏览器需要知道目标服务器的IP才能建立连接。将域名解析为IP的这个系统就是DNS。这个通常可以利用DNS缓存结果达到减少这个时间的目的。</li><li>建立连接(initial connection): HTTP是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较为明显，慢启动则对文件类大请求影响较大。</li></ul><h2 id="HTTP1-0与HTTP1-1"><a href="#HTTP1-0与HTTP1-1" class="headerlink" title="HTTP1.0与HTTP1.1"></a>HTTP1.0与HTTP1.1</h2><p>最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用在现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。主要区别体现在:</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>缓存处理，HTTP1.0中主要使用header里的If-Modified-Since，Expires来作为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，例如Entity，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>宽带优化及网络连接的使用，HTTP1.0中，存在浪费宽带的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码206(Partial Content)，这样就方便了开发者自由的选择以便于充分选择利用宽带和连接。</li><li>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409(Conflict)表示服务器上的某个资源被永久性的删除。</li><li>长连接，HTTP1.1支持长连接和请求流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keey-alive，一定程度上弥补了HTTP1.O每次请求都要创建连接的缺点。</li><li>Host头处理，在HTTP1.0中认为每一台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名(hostname)。但随着虚拟机技术的发展，在一台物理服务器上可以存在多个虚拟机，并且他们共享一个IP地址。HTTP1.1中的请求消息和响应消息都应该支持Hose头域，且请求消息中如果没有Host头域会报告一个错误(440 Bad Request)。</li></ol><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>HTTP1.0在传输数据时，每次都要重新建立连接，无疑增加了大量的延迟时间，特别是移动端表现更为突出。</li><li>HTTP1.x在传输数据时，所有传输的内容都是明文的，无法保证数据的安全性。</li><li>HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户的流量。</li><li>虽然HTTP1.x支持keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用同样会给服务器端带来大量的性能压力，并且对于单个文件被不断请求的服务（例如图片存放网站），keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p><p>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h3 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h3><h4 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p><p><img src="/img/httprequest.png" alt=""></p><h4 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="/img/httpmessage.jpg" alt=""></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>客户端请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; GET / HTTP/1.1</div><div class="line">&gt; Host: localhost:3000</div><div class="line">&gt; User-Agent: curl/7.47.0</div><div class="line">&gt; Accept: */*</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>服务端响应:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt; HTTP/1.1 200 OK</div><div class="line">&lt; Content-Type: text/plain</div><div class="line">&lt; Date: Tue, 31 Oct 2017 14:11:22 GMT</div><div class="line">&lt; Connection: keep-alive</div><div class="line">&lt; Transfer-Encoding: chunked</div><div class="line">&lt; </div><div class="line">Hello World</div></pre></td></tr></table></figure></p><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><ul><li>GET: 最常用的方法，通常用于请求服务器发送某个资源。</li><li>POST: 起初是用来向服务器输入数据，实际上通常用来把表单数据传输到服务器。</li><li>PUT: 与GET从服务器读取文档相反，PUT方法会向服务器写入文档。</li><li>DELETE: 请求服务器删除指定的资源。</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>HTTP状态码:</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul><p>HTTP状态码分类: </p><ul><li>1**    信息，服务器收到请求，需要请求者继续执行操作</li><li>2**    成功，操作被成功接收并处理</li><li>3**    重定向，需要进一步的操作以完成请求</li><li>4**    客户端错误，请求包含语法错误或无法完成请求</li><li>5**    服务器错误，服务器在处理请求的过程中发生了错误</li></ul><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><p>Node的http模块包含了对HTTP处理的封装。在Node中，HTTP服务继承了TCP服务器(net模块)，它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装。</p><p><img src="/img/http.png" alt=""></p><p>http模块将connection到request的过程进行了封装</p><p>除此之外，http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿出连接中的传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头，触发request事件，调用用户的业务逻辑。该逻辑的示意图:</p><p><img src="/img/theprocessofhttp.png" alt=""></p><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><p>对TCP连接的读操作，http模块将其封装为ServerRequest对象。请求报文头部将会通过http_parser进行解析。</p><p>报头被解析后放置在req.headers属性上传递给业务逻辑以供调用。</p><p>报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作，如下所示: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(req, res) =&gt; &#123;</div><div class="line">    <span class="comment">//console.log(req.headers);</span></div><div class="line">    <span class="keyword">let</span> buffers = [];</div><div class="line">    req.on(<span class="string">'data'</span>, chunk =&gt; &#123;</div><div class="line">        buffers.push(chunk);</div><div class="line">    &#125;);</div><div class="line">    res.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">        <span class="keyword">let</span> buffer = Buffer.concat(buffers);</div><div class="line">        res.end(<span class="string">'Hello World'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>HTTP请求对象和HTTP响应对象是相对较底层的封装，现行的Web框架express就是在这两个对象的基础上进行高层封装完成的。</p><h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><p>HTTP响应封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的API为res.setHeader()和res.writeHead()。在上述报文示例中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</div></pre></td></tr></table></figure><p>其分为setHeader()和writeHead()两个步骤。它在http模块的封装下，实际生成如下的报文: </p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt; HTTP/1.1 200 OK</div><div class="line">&lt; Content-Type: text/plain</div></pre></td></tr></table></figure><p>我们可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中。除此之外，http模块会自动帮你设置一些头信息，如下所示:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt; Date: Tue, 31 Oct 2017 14:11:22 GMT</div><div class="line">&lt; Connection: keep-alive</div><div class="line">&lt; Transfer-Encoding: chunked</div><div class="line">&lt;</div></pre></td></tr></table></figure><p>响应结束后，HTTP服务器将可能会将当前连接用于下一个请求，或者关闭连接。值得注意的是，报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不会再生效。这有协议的特性决定的。</p><h3 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> server =  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</div><div class="line">    res.end(<span class="string">'Hello World\n'</span>);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8080</span>, <span class="string">'127.0.0.1'</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'server runing at http://localhost:127.0.0.1:1337/'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>NODE获取客户端IP:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req.headers[<span class="string">'x-forwarded-for'</span>] || req.connection.remoteAddress || req.socket.remoteAddress;</div></pre></td></tr></table></figure><p>NODE获取客户端PORT:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req.connection.remotePort || req.socket.remotePort;</div></pre></td></tr></table></figure></p><h4 id="HTTP服务器的事件"><a href="#HTTP服务器的事件" class="headerlink" title="HTTP服务器的事件"></a>HTTP服务器的事件</h4><p>如同TCP服务一样，HTTP服务器也抽象了一些事件，以供应用层使用，同样典型的是，服务器也是一个EventEmitter实例。</p><ul><li><p>connection事件: 在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接有可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。</p></li><li><p>request事件: 建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。</p></li><li><p>close事件: 与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以server.close()传递一个回调函数来快速注册该事件。</p></li><li><p>connect事件: 当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起请求的连接将会关闭。</p></li><li><p>upgrade事件: 当客户端要求升级连接协议时，需要和服务器协商，客户端会在请求头中带上Upgrade字段，服务器端会在接受到这样的请求时触发该事件。如果不监听该事件，发起该请求的连接将会被关闭。</p></li><li><p>clientError事件: 连接的客户触发error事件时，这个错误会传递到服务器端，此时触发该事件。</p></li></ul><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><blockquote><p>从协议的角度来说，现在的应用，如浏览器，其实是一个HTTP的代理，用户的行为将会通过它转化为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上。HTTP服务只做两件事情: 处理HTTP请求和发送HTTP响应。</p></blockquote><p>http模块提供了一个底层API: http.request(options, connect)，用于构造HTTP客户端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> options = &#123;</div><div class="line">    hostname: <span class="string">'127.0.0.1'</span>,</div><div class="line">    port: <span class="number">1334</span>,</div><div class="line">    path: <span class="string">'/'</span>,</div><div class="line">    method: <span class="string">'GET'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> req = http.request(options, res =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'STATUS: '</span> + res.statusCode);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'HEADERS: '</span> + <span class="built_in">JSON</span>.stringify(res.headers));</div><div class="line">    res.setEncoding(<span class="string">'uft8'</span>);</div><div class="line">    res.on(<span class="string">'data'</span>, chunk =&gt; &#123;</div><div class="line">        <span class="built_in">console</span>.log(chunk);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">req.end();</div></pre></td></tr></table></figure><p>options参数决定了这个HTTP请求头中的内容，它的选项有如下这些。</p><ul><li>host: 服务器的域名或IP地址，默认为localhost。</li><li>hostname: 服务器名称。</li><li>port: 服务器端口，默认为80。</li><li>socketPath: Domain套接字路径。</li><li>method: HTTP请求方法，默认为GET。</li><li>path: 请求路径，默认为/。</li><li>headers: 请求头对象。</li><li>auth: Basic认证，这个值将被计算成请求头中的Authorization部分。</li></ul><h4 id="客户端事件"><a href="#客户端事件" class="headerlink" title="客户端事件:"></a>客户端事件:</h4><ul><li>response: 与服务端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。</li><li>socket: 当底层连接池中建立的连接分配给当前请求对象时，触发该事件。</li><li>connect: 当客户端向服务器端发起CONNECT请求时，如果服务器响应了200状态码，客户端将会触发该事件。</li><li>upgrade: 客户端向服务器端发起Upgrade请求时，如果服务器响应了101 Switching Protocols状态，客户端将会触发该事件。</li><li>continue: 客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件。 </li></ul><blockquote><p>在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完就触发response事件，同时传递一个响应对象以供操作ClientResponse。</p><p>TCP和UDP都属于网络传输协议，如果要构造高效的网络应用，就应该从传输层进行着手。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;作为一个WEB开发者，了解一些常用的协议是必须的，本编将总结自己在协议方面的学习。&lt;/p&gt;
    
    </summary>
    
      <category term="NODEJS" scheme="http://qinyongli.cn/categories/NODEJS/"/>
    
    
      <category term="HTTP" scheme="http://qinyongli.cn/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>TCP、UDP、Socket总结</title>
    <link href="http://qinyongli.cn/2017/10/28/TCP%E3%80%81UDP%E3%80%81Socket%E6%80%BB%E7%BB%93/"/>
    <id>http://qinyongli.cn/2017/10/28/TCP、UDP、Socket总结/</id>
    <published>2017-10-28T14:56:46.000Z</published>
    <updated>2017-11-01T10:44:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本篇将开启我对各种协议的理解总结。</p><a id="more"></a><h2 id="UDP与TCP与Socket"><a href="#UDP与TCP与Socket" class="headerlink" title="UDP与TCP与Socket"></a>UDP与TCP与Socket</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。</p><p>Socket的英文原义是”孔”或”插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。</p><p>socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p><p><img src="/img/socket.jpg" alt=""></p><h4 id="Server-Client模型"><a href="#Server-Client模型" class="headerlink" title="Server-Client模型"></a>Server-Client模型</h4><p>服务器，使用ServerSocket监听指定的端口，端口可以随意指定（由于1024以下的端口通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于1024的端口），等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。</p><p>客户端，使用Socket对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话完成后，关闭Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个1024以上的端口。</p><p>Socket接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。要学Internet上的TCP/IP网络编程，必须理解Socket接口。Socket接口设计者最先是将接口放在Unix操作系统里面的。如果了解Unix系统的输入和输出的话，就很容易了解Socket了。网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用Socket（），该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p><p><img src="/img/socket.png" alt=""></p><h4 id="常用的套接字类型2中折叠常用的Socket类型"><a href="#常用的套接字类型2中折叠常用的Socket类型" class="headerlink" title="常用的套接字类型2中折叠常用的Socket类型"></a>常用的套接字类型2中折叠常用的Socket类型</h4><ul><li>流式套接字（SOCK_STREAM）：面向连接的Socket，针对于面向连接的TCP服务应用。</li><li>数据报式套接字（SOCK_DGRAM）：无连接的Socket，对应于无连接的UDP服务应用。</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP服务在网络应用中十分常见，目前大多数的应用都是基于TCP搭建而成。典型的HTTP、SMTP、IMAP等协议。</p><p>TCP(传输控制协议)是面向连接的、传输可靠（保证数据正确性且保证数据顺序）、用于传输大量数据（流模式）、速度快，建立连接需要开销多（时间、系统资源）。</p><h4 id="TCP服务器端"><a href="#TCP服务器端" class="headerlink" title="TCP服务器端"></a>TCP服务器端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="params">socket</span> =&gt;</span> &#123;</div><div class="line">    socket.on(<span class="string">'data'</span>, data =&gt; &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`接受到客户端发来的数据: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">        socket.write(<span class="string">'你好'</span>);</div><div class="line">    &#125;);</div><div class="line">    socket.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'断开链接'</span>);</div><div class="line">    &#125;);</div><div class="line">    socket.write(<span class="string">'欢迎光临nodejs应用\n'</span>);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8124</span>, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'server bound'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">const</span> client = net.connect(&#123;<span class="attr">port</span>: <span class="number">8124</span>&#125;, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</div><div class="line">    client.write(<span class="string">'Hello World!'</span>);</div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'data'</span>, data =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(data.toString());</div><div class="line">    client.end();</div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'end'</span>,() =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'client disconnected'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="TCP服务事件"><a href="#TCP服务事件" class="headerlink" title="TCP服务事件"></a>TCP服务事件</h4><h5 id="服务器事件"><a href="#服务器事件" class="headerlink" title="服务器事件"></a>服务器事件</h5><p>对于通过net.createServer()创建的服务器而言，它是一个EventEmiter实例，它的自定以事件有如下几种。</p><ul><li>listening: 在调用server.listen()绑定端口或Domain Socket后触发。</li><li>connection: 每个客户端套接字连接到服务器端时触发。</li><li>close:　当服务器关闭时触发, 在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。</li><li>error: 当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常。</li></ul><h5 id="连接事件"><a href="#连接事件" class="headerlink" title="连接事件"></a>连接事件</h5><p>服务器可以同时与多个客户端保持连接，对于每一个连接而言是典型的可写可读Stream对象。Stream对象可以用于服务器和客户端之间的通信，既可以通过data事件从一端读取另一端发来的数据，也可以通过write()方法从一端向另一端发送数据。它具有如下的自定义事件。</p><ul><li>data: 当一端调用write()发送数据时，另一端将会触发data事件，事件传递的数据即是write()发送的数据。</li><li>end: 当连接中的任意一端发送了FIN数据时，将会触发该事件。</li><li>connect: 该事件用于客户端，当套接字与服务器端连接成功时会被触发。</li><li>drain: 当任意一端调用write()发送数据时，当前这段会触发该事件。</li><li>error: 当异常发生时，触发该事件。</li><li>timeout: 当一定事件后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置。</li></ul><p>另外，由于TCP套接字是可读可写的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="params">socket</span> =&gt;</span> &#123;</div><div class="line">    socket.write(<span class="string">'Echo server \r\n'</span>);</div><div class="line">    socket.pipe(socket);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</div></pre></td></tr></table></figure></p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP(用户数据包协议)面向非连接、传输不可靠、用于传输少量数据（数据报模式）、速度快，UDP传输的可靠性由应用层负责。</p><p>UDP报头: </p><p><img src="https://p1.ssl.qhmsg.com/dr/220__/t013b598635950ce8ea.png" alt=""></p><p>TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通讯，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通讯，它虽然提供面向事务的简单不可靠的信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，如果音频、视频等。UDP目前应用很广泛，DNS服务器是基于它实现的。</p><h4 id="创建UDP套接字"><a href="#创建UDP套接字" class="headerlink" title="创建UDP套接字"></a>创建UDP套接字</h4><p>创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接受数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</div><div class="line"><span class="keyword">const</span> socket = dgram.createSocket(<span class="string">'udp4'</span>);</div></pre></td></tr></table></figure><p>####　创建UDP服务器端</p><p>若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可。以下为一个完整的服务器端示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</div><div class="line"><span class="keyword">const</span> server = dgram.createSocket(<span class="string">'udp4'</span>);</div><div class="line">server.on(<span class="string">'message'</span>, (msg, rinfo) =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`server got: <span class="subst">$&#123;msg&#125;</span> from <span class="subst">$&#123;rinfo.address&#125;</span>:<span class="subst">$&#123;rinfo.port&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">let</span> address = server.address();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`server listening <span class="subst">$&#123;address.address&#125;</span>:<span class="subst">$&#123;address.port&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line">server.bind(<span class="number">41234</span>);</div></pre></td></tr></table></figure><p>该套接字将接收所有网卡上41234端口上的消息。在绑定完成后，将触发listening事件。</p><h4 id="创建UDP客户端"><a href="#创建UDP客户端" class="headerlink" title="创建UDP客户端"></a>创建UDP客户端</h4><p>创建一个客户端与服务器端进行对话，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</div><div class="line"><span class="keyword">const</span> message = <span class="keyword">new</span> Buffer(<span class="string">"深入浅出nodejs"</span>);</div><div class="line"><span class="keyword">const</span> client = dgram.createSocket(<span class="string">'udp4'</span>);</div><div class="line">client.send(message, <span class="number">0</span>, message.length, <span class="number">41234</span>, <span class="string">'localhost'</span>, (err, bytes) =&gt; &#123;</div><div class="line">    client.close();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>当套接字对象用在客户端时，可以调用send()方法发送消息到网络中。send()方法的参数如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket.send(buf, offset, length, port, address, [callback]);</div></pre></td></tr></table></figure><p>这些参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调。与TCP套接字的write相比,send()方法的参数列表相对复杂，但是它更灵活的地方在于可以随意发送数据到网络中的服务器端，而TCP如果要发送数据给另一个服务器端，则需要重新通过套接字构造新的连接。</p><h4 id="UDP套接字事件"><a href="#UDP套接字事件" class="headerlink" title="UDP套接字事件"></a>UDP套接字事件</h4><p>UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream实例。它具备如下自定义事件:</p><ul><li>message: 当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址消息。</li><li>listening: 当UDP套接字开始侦听时触发该事件。</li><li>close: 调用close()方法时触发该事件，并不在触发message事件。如需再次触发message事件，重新绑定即可。</li><li>error: 当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;本篇将开启我对各种协议的理解总结。&lt;/p&gt;
    
    </summary>
    
      <category term="NODEJS" scheme="http://qinyongli.cn/categories/NODEJS/"/>
    
    
      <category term="Internet" scheme="http://qinyongli.cn/tags/Internet/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常用设计模式</title>
    <link href="http://qinyongli.cn/2017/10/28/JavaScript%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://qinyongli.cn/2017/10/28/JavaScript常用设计模式/</id>
    <published>2017-10-28T05:24:23.000Z</published>
    <updated>2017-11-02T07:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的JavaScript应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。</p><a id="more"></a><h2 id="常用的设计模式"><a href="#常用的设计模式" class="headerlink" title="常用的设计模式"></a>常用的设计模式</h2><ul><li>工厂模式</li><li>单体模式</li><li>模块模式</li><li>代理模式</li><li>策略模式</li><li>发布-订阅模式</li><li>观察者模式</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是为了解决多个类似的对象声明的问题，也就是为了解决实例化对象产生的重复问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name, age, sex</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = name;</div><div class="line">    obj.age = age;</div><div class="line">    obj.sex = sex;</div><div class="line">    obj.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> CreatePerson(<span class="string">'xiaowang'</span>, <span class="string">'20'</span>, <span class="string">'boy'</span>);</div><div class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> CreatePerson(<span class="string">'mary'</span>, <span class="string">'18'</span>, <span class="string">'girl'</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.name);<span class="comment">//xiaowang</span></div><div class="line"><span class="built_in">console</span>.log(person2.name);<span class="comment">//may</span></div><div class="line"></div><div class="line"><span class="comment">//返回都是object，无法识别对象的类型，不知道他们是哪个对象的实例。</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person1);<span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person2);<span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></div></pre></td></tr></table></figure><blockquote><p>优点: 能解决多个相似的问题<br>缺点: 不能知道对象识别的问题(对象的类型不知道)</p></blockquote><h3 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h3><p>单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象。如果它可以被实例化，那么它只能被实例化一次。</p><p>对象字面量来创建单体模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Singleton = &#123;</div><div class="line">    attr1: <span class="number">1</span>,</div><div class="line">    attr2: <span class="number">2</span>,</div><div class="line">    method1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attr1;</div><div class="line">    &#125;,</div><div class="line">    method2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attr2;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>单体化模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(!instance) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton(name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="keyword">let</span> a = getInstance(<span class="string">'aa'</span>);</div><div class="line"><span class="keyword">let</span> b = getInstance(<span class="string">'bb'</span>);</div><div class="line"><span class="built_in">console</span>.log(a == b);<span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(a.getName());<span class="comment">//aa</span></div><div class="line"><span class="built_in">console</span>.log(b.getName());<span class="comment">//aa</span></div></pre></td></tr></table></figure><p>单体模式的优点:</p><ul><li>可以来用划分命令空间，减少全局变量。</li><li>使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。</li></ul><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Single = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//私有变量</span></div><div class="line">    <span class="keyword">let</span> privateNum = <span class="number">112</span>;</div><div class="line">    <span class="comment">//公有变量</span></div><div class="line">    <span class="keyword">let</span> publicNum = <span class="number">110</span>;</div><div class="line">    <span class="comment">//私有函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//业务逻辑代码</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//公有函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">publicFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//业务逻辑代码</span></div><div class="line">    &#125;；</div><div class="line">    <span class="comment">//返回一个对象包含公有方法和属性</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        publicNum,</div><div class="line">        publicFunc</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明一个妹子</span></div><div class="line"><span class="keyword">let</span> AGirl = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//声明一个男孩</span></div><div class="line"><span class="keyword">let</span> ABoy = <span class="function"><span class="keyword">function</span> (<span class="params">girl</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.girl = girl;</div><div class="line">    <span class="comment">//送礼物给一个妹子</span></div><div class="line">    <span class="keyword">this</span>.sendMarriageGift = <span class="function"><span class="keyword">function</span> (<span class="params">gift</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'Hi '</span> + <span class="keyword">this</span>.girl.name + <span class="string">', a　boy 送你一个礼物: '</span> + gift;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//代理人</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">Proxy</span> = <span class="function"><span class="keyword">function</span> (<span class="params">girl</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.girl = girl;</div><div class="line">    <span class="keyword">this</span>.sendGift = <span class="function"><span class="keyword">function</span> (<span class="params">gift</span>) </span>&#123;</div><div class="line">        <span class="keyword">new</span> ABoy(girl).sendMarriageGift(gift);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//初始化</span></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="keyword">new</span> AGirl(<span class="string">'漂亮妹子'</span>));</div><div class="line">proxy.sendGift(<span class="string">'结婚戒'</span>);<span class="comment">//Hi 漂亮妹子, a boy 送你一个礼物：　结婚戒</span></div></pre></td></tr></table></figure><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> stragegy = &#123;</div><div class="line">    <span class="string">'A'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'B'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">'C'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">salary</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> salay * <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> calculateBount = <span class="function"><span class="keyword">function</span> (<span class="params">level, salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> stragegy[level](salary);</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(calculateBount(<span class="string">'A'</span>, <span class="number">10000</span>));</div></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>根据状态的变化主动触发观察者队列、hashMap的回调行为。redux中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.observers = [];</div><div class="line">&#125;;</div><div class="line">Observer.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.observers.push(fn);</div><div class="line">&#125;;</div><div class="line">Observer.prototype.unsubscribe = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.observers = <span class="keyword">this</span>.observers.filter(<span class="function"><span class="params">_fn</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> _fn !== fn;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">Observer.prototype.update = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.observers.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</div><div class="line">        fn(val);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> Ob = <span class="keyword">new</span> Observer();</div><div class="line"><span class="keyword">const</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;val&#125;</span>`</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`它是<span class="subst">$&#123;val&#125;</span>`</span>);</div><div class="line">&#125;;</div><div class="line">Ob.subscribe(fn1);</div><div class="line">Ob.subscribe(fn2);</div><div class="line">Ob.update(<span class="string">'nodejs'</span>);</div><div class="line">Ob.unsubscribe(fn2);</div><div class="line">Ob.update(<span class="string">'JavaScript'</span>);</div></pre></td></tr></table></figure><h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">PubSub</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.eventPool = [];</div><div class="line">&#125;;</div><div class="line">PubSub.prototype.publish = <span class="function"><span class="keyword">function</span>(<span class="params">topicName, ...arg</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.eventPool[topicName] &amp;&amp; <span class="keyword">this</span>.eventPool[topicName].forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</div><div class="line">        callback(arg);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">PubSub.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">topicName, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> topic = <span class="keyword">this</span>.eventPool[topicName];</div><div class="line">    <span class="keyword">if</span>(!topic)</div><div class="line">        <span class="keyword">this</span>.eventPool[topicName] = [];</div><div class="line">    <span class="keyword">this</span>.eventPool[topicName].push(callback);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> pub = <span class="keyword">new</span> PubSub();</div><div class="line">pub.subscribe(<span class="string">'node'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`收到:<span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line">pub.publish(<span class="string">'node'</span>, <span class="string">'nodejs'</span>);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的JavaScript应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="设计模式" scheme="http://qinyongli.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JS内存</title>
    <link href="http://qinyongli.cn/2017/10/26/%E6%B5%85%E8%B0%88JS%E5%86%85%E5%AD%98/"/>
    <id>http://qinyongli.cn/2017/10/26/浅谈JS内存/</id>
    <published>2017-10-26T11:48:34.000Z</published>
    <updated>2017-10-27T10:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>与前端不同，后端是直面服务器的，所以对性能的要求更高，对内存有更高的要求。如果存在内存泄漏，跟随着时间的流逝，内存泄漏越来越多，程序运行也会越来越慢，最终崩溃。所以要想深入学习node，控制内存的使用是至关重要的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;与前端不同，后端是直面服务器的，所以对性能的要求更高，对内存有更高的要求。如果存在内存泄漏，跟随着时间的流逝，内存泄漏越来越多，程序运行也会
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="Memory" scheme="http://qinyongli.cn/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>浅谈curry化</title>
    <link href="http://qinyongli.cn/2017/10/25/%E6%B5%85%E8%B0%88curry%E5%8C%96/"/>
    <id>http://qinyongli.cn/2017/10/25/浅谈curry化/</id>
    <published>2017-10-25T12:12:02.000Z</published>
    <updated>2017-10-28T07:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在函数式编程中我了解到了柯里化，并且觉得它很有意思，所以对它的实现原理进行了探索，其中难点还真不少。</p><a id="more"></a><h2 id="curry化的概念"><a href="#curry化的概念" class="headerlink" title="curry化的概念"></a>curry化的概念</h2><p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><p>你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用</p><h2 id="curry化的实现代码"><a href="#curry化的实现代码" class="headerlink" title="curry化的实现代码"></a>curry化的实现代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sub_curry = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> curry = <span class="function"><span class="keyword">function</span>(<span class="params">fn, len</span>) </span>&#123;</div><div class="line">    len = len || fn.length;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; len) &#123;</div><div class="line">            <span class="keyword">let</span> combined = [fn].concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>));</div><div class="line">            <span class="keyword">return</span> curry(sub_curry.apply(<span class="keyword">this</span>, combined), len - <span class="built_in">arguments</span>.length);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="curry化使用的哪些知识点"><a href="#curry化使用的哪些知识点" class="headerlink" title="curry化使用的哪些知识点"></a>curry化使用的哪些知识点</h2><ul><li>闭包</li><li>递归</li></ul><h2 id="curry难点解析"><a href="#curry难点解析" class="headerlink" title="curry难点解析"></a>curry难点解析</h2><p>难点是下面这句话的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sub_curry.apply(<span class="keyword">this</span>, combined)</div></pre></td></tr></table></figure><p>这个语句返回一个闭包，并且这个闭包中的fn是前面一个函数。</p><p>附上一张图理解。</p><p><img src="/img/closure.png" alt=""></p><p>这个最终的目的就是把所有的参数传递给fn调用</p><p>附上演示的栗子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> multiply = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a * b * c;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> multiplyCurry = curry(multiply);</div><div class="line"><span class="built_in">console</span>.log(multiplyCurry(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">4</span>));</div><div class="line"><span class="comment">//=&gt;24</span></div></pre></td></tr></table></figure><blockquote><p>另一种实现</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 另一种简单实现，参数只能从右到左传递</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCurry</span>(<span class="params">func, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arity = func.length;</div><div class="line">    <span class="keyword">var</span> args = args || [];</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">        [].push.apply(_args, args);</div><div class="line">        <span class="comment">// 如果参数个数小于最初的func.length，则递归调用，继续收集参数</span></div><div class="line">        <span class="keyword">if</span> (_args.length &lt; arity) &#123;</div><div class="line">            <span class="keyword">return</span> createCurry.call(<span class="keyword">this</span>, func, _args);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 参数收集完毕，则执行func</span></div><div class="line">        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, _args);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在函数式编程中我了解到了柯里化，并且觉得它很有意思，所以对它的实现原理进行了探索，其中难点还真不少。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="FP" scheme="http://qinyongli.cn/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>FP-Pointfree编程指南</title>
    <link href="http://qinyongli.cn/2017/10/25/FP-Pointfree%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>http://qinyongli.cn/2017/10/25/FP-Pointfree编程指南/</id>
    <published>2017-10-25T05:55:32.000Z</published>
    <updated>2017-10-28T07:17:35.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><a id="more"></a><h2 id="Pointfree"><a href="#Pointfree" class="headerlink" title="Pointfree"></a>Pointfree</h2><h3 id="Pointfree概念"><a href="#Pointfree概念" class="headerlink" title="Pointfree概念"></a>Pointfree概念</h3><p>pointfree 模式指的是，永远不必说出你的数据</p><p>不使用所要处理的值，只合成运算过程。</p><p>example</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> compose = <span class="function"><span class="keyword">function</span> (<span class="params">f, g</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> f(g(x));</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">let</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</div><div class="line"><span class="keyword">let</span> addOneSquare = compose(square, addOne);</div><div class="line">addOneSquare(<span class="number">2</span>);</div><div class="line"><span class="comment">//=&gt;9</span></div></pre></td></tr></table></figure><p>上面一个栗子，把两个函数组合，然后求值。</p><p>addOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。</p><h3 id="Pointfree的本质"><a href="#Pointfree的本质" class="headerlink" title="Pointfree的本质"></a>Pointfree的本质</h3><p>Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。</p><p>example: 读取对象的role属性，不要直接写成obj.role, 而是要把这个操作封装成函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> prop = <span class="function">(<span class="params">p, obj</span>) =&gt;</span> obj[p];</div><div class="line"><span class="keyword">let</span> propRole = curry(prop)(<span class="string">'role'</span>);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://qinyongli.cn/categories/JavaScript/"/>
    
    
      <category term="FP" scheme="http://qinyongli.cn/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TCP/IP</title>
    <link href="http://qinyongli.cn/2017/10/21/%E6%B5%85%E8%B0%88TCP-IP/"/>
    <id>http://qinyongli.cn/2017/10/21/浅谈TCP-IP/</id>
    <published>2017-10-21T14:46:48.000Z</published>
    <updated>2017-10-26T16:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>作为一名计算机科学与技术的工科生，了解计算机网络基础是必须的。网络通讯遍布在我们身边，从本博客开始，将启航我在计算机网络上的系列学习。</p><a id="more"></a><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI 模型(开放系统互联模型)是一个由国际标准化组织(ISO)提出概念模型,试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。</p><p>OSI　将计算机网络体系结构划分为七层,每层都可以提供抽象良好的接口。了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。</p><p>七层协议，从下往上</p><ol><li>物理层(网络物理硬件)</li><li>链路层(网络特有的链路接口)</li><li>网络层(IP)</li><li>传输层(TCP/UDP)</li><li>会话层(通信连接/维持会话)</li><li>表示层(加密/解密等)</li><li>应用层(HTTP、SMTP、IMAP等)</li></ol><p>附上三个图促进理解</p><p><img src="/img/OSI1.jpg" alt="OSI图片"></p><p><img src="/img/OSI2.gif" alt="OSI图片"></p><p><img src="/img/OSI3.png" alt="OSI图片"></p><blockquote><p>物理地址，又称网卡的硬件MAC地址(处于数据链路层)负责局域网通讯，IP地址(处于网络层)负责外网通讯</p></blockquote><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>TCP/IP模型也被称作DoD模型(Department of Defense Model)。TCP/IP字面上代表了两个协议：TCP（传输控制协议）和IP（网际协议）。但TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族。从协议分层模型方面来讲，TCP/IP由四个层次组成:网络接口层、网络层、传输层、应用层。TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。</p><blockquote><p>OSI模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去。</p><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>TCP/IP 的设计,是吸取了分层模型的精华思想——封装。每层对上一层提供服务的时候,上一层的数据结构是黑盒,直接作为本层的数据,而不需要关心上一层协议的任何细节</p></blockquote><p>四层模型:</p><p><img src="/img/tipcip&amp;osi.png" alt="tcp/ip四层模型图"></p><p><img src="/img/application.png" alt="tcp/ip图片"></p><p>TCP/IP 分层模型的分层以以太网上传输 UDP 数据包如图所示</p><p><img src="/img/TCPIP.png" alt="tcp/ip图片"></p><p>各层中的协议</p><p><img src="/img/protocol.jpg" alt=""></p><p><img src="/img/tcpipstream.jpg" alt="tcpip通讯流"></p><p>基于tcp的文件传输(ftp－port21)</p><p><img src="/img/datapackage.png" alt=""></p><p>基于TCP和UDP的数据封装及解析示例如下：</p><p><img src="/img/package.jpg" alt=""></p><p>TCP数据包</p><p><img src="/img/tcppackage.jpg" alt=""></p><p>tcp在真正连接前要经过三次握手，断开连接需要经过四次挥手</p><p>TCP三次握手</p><p><img src="/img/threeShake.png" alt=""></p><p>TCP四次挥手</p><ul><li><p>第一次挥手</p><p>  主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p></li><li><p>第二次挥手</p><p>  被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</p></li><li><p>第三次挥手</p><p>  被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了</p></li><li><p>第四次挥手</p><p>  主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p></li></ul><p><img src="/img/waved.jpg" alt="四次挥手图片"></p><h3 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a>IP数据包</h3><p>以太网数据包(packet)的大小是固定的，最初是1518字节，后来增加到1522字节。其中，1500字节是负载(pyload)，22字节是头部信息(head)。</p><p>IP数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以IP数据包的负载最多为1480字节。</p><p>IP数据包</p><p><img src="/img/ipPackage.png" alt="paket数据包"></p><blockquote><p>IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。</p></blockquote><p>TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。</p><p>因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。</p><p><img src="/img/packet2.png" alt="packet数据包"></p><p>（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;作为一名计算机科学与技术的工科生，了解计算机网络基础是必须的。网络通讯遍布在我们身边，从本博客开始，将启航我在计算机网络上的系列学习。&lt;/p&gt;
    
    </summary>
    
      <category term="Internet" scheme="http://qinyongli.cn/categories/Internet/"/>
    
    
      <category term="TCP/IP" scheme="http://qinyongli.cn/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MVX</title>
    <link href="http://qinyongli.cn/2017/10/21/%E6%B5%85%E8%B0%88MVX/"/>
    <id>http://qinyongli.cn/2017/10/21/浅谈MVX/</id>
    <published>2017-10-21T05:06:30.000Z</published>
    <updated>2017-10-23T13:34:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>MVC框架最早出现在Java领域，然后慢慢的在前端开发中也被提到，后来又出现了MVP，以及现在最成熟的MVVM</p><a id="more"></a><h2 id="MVX"><a href="#MVX" class="headerlink" title="MVX"></a>MVX</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC（Model-View-Controller）是应用最广泛的软件架构之一，一般MVC分为: Model(模型)、Controller(控制器)和View(视图)。这主要是基于分层的目的，让彼此的职责分开。</p><p>控制器（Controller），一组行为的集合。(业务逻辑)</p><p>模型（Model），数据相关的操作和封装。(数据保存)</p><p>视图（View），视图的渲染。(用户界面)</p><p>View一般通过Controler来和Model进行联系的。Controller是Model和View的协调者，View和Model不直接联系。基本联系都是单项的。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020105.png" alt=""></p><ol><li>View 传送指令到Controler</li><li>Controller 完成业务逻辑，要求 Model 改变状态</li><li>Model 将新的数据发送到　View，用户得到反馈</li></ol><p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020106.png" alt=""></p><p>另一种是直接通过controller接受指令。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020107.png" alt=""></p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>MVP模式将 Controller改名为Persenter,　同时改变了通信方向。</p><p><img src="http://image.beekka.com/blog/2015/bg2015020109.png" alt=""></p><ol><li>各部分之间的通信，都是双向的。</li><li>View 与 Model不发生联系。都通过Persenter传递。</li><li>View 非常薄, 不部署任何业务逻辑，称为”被动视图”，即没有任何主动性，而Persenter非常厚，所有逻辑都部署在那里。</li></ol><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM模式将Persenter改名为ViewModel，基本上与MVP完全一致</p><p><img src="http://image.beekka.com/blog/2015/bg2015020110.png" alt=""></p><p>唯一的区别是，它采用双向绑定(data-binding): View的变动，自动反映在ViewModel，反之亦然。Angular和Vue采用这种模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;MVC框架最早出现在Java领域，然后慢慢的在前端开发中也被提到，后来又出现了MVP，以及现在最成熟的MVVM&lt;/p&gt;
    
    </summary>
    
      <category term="Architecture" scheme="http://qinyongli.cn/categories/Architecture/"/>
    
    
      <category term="MVX" scheme="http://qinyongli.cn/tags/MVX/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Web缓存</title>
    <link href="http://qinyongli.cn/2017/10/19/%E6%B5%85%E8%B0%88Web%E7%BC%93%E5%AD%98/"/>
    <id>http://qinyongli.cn/2017/10/19/浅谈Web缓存/</id>
    <published>2017-10-19T00:48:57.000Z</published>
    <updated>2017-10-31T05:43:23.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。</p><a id="more"></a><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><ul><li>数据库缓存</li><li>代理服务器缓存</li><li>CDN缓存</li><li>浏览器缓存</li></ul><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>页面的缓存状态是由header决定的，header的参数有四种。</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>其优先级要比Expires高</p><ul><li><p>max-age</p><p>  单位为s，指定设置缓存最大的有效时间，定义时间的长短。当浏览器向服务器发送请求过后，在max-age这段时间里浏览器就不会再向服务器发送请求了。</p><p>  example</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</div><div class="line"><span class="keyword">const</span> host = <span class="string">'127.0.0.1'</span>;</div><div class="line"><span class="keyword">const</span> server = http.createServer();</div><div class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span>(req.url == <span class="string">'/'</span>) &#123;</div><div class="line">        <span class="built_in">console</span>.log(req.url);</div><div class="line">        fs.readFile(<span class="string">'./index.html'</span>, (err, data) =&gt; &#123;</div><div class="line">            res.statusCode = <span class="number">200</span>;</div><div class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</div><div class="line">            <span class="comment">//设置Cache-Control缓存</span></div><div class="line">            res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=60'</span>);</div><div class="line">            res.end(data);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">server.listen(port, host, () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`server serve at http://<span class="subst">$&#123;host&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>  在firefox输入网址后回车，然后在地址栏再次回车。控制台输入的结果如图</p><p>  <img src="/img/cache-control1.png" alt=""></p><p>  一次请求</p><p>  不设置缓存，控制输入的结果如图</p><p>  <img src="/img/cache-control2.png" alt=""></p><p>  两次请求</p></li><li><p>s-maxage</p><p>  单位为s，同max-age，只是用于共享缓存(比如CDN缓存)</p><p>  比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通的缓存，而s-maxage用于代理缓存。<br>  如果存在s-maxage，则会覆盖掉max-age和Expires header</p></li><li><p>public</p><p>  指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定public还是private，则默认为public</p></li><li><p>private</p><p>  响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private</p></li><li><p>no-cache</p><p>  指定不缓存响应</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-cache'</span>);</div></pre></td></tr></table></figure><p>  设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间</p></li><li><p>no-store</p><p>  绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存，每次请求资源都要从服务器重新获取</p></li></ul><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>单位为毫秒ms，缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res.setHeader(<span class="string">'Expires'</span>, <span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">60</span> * <span class="number">2</span> * <span class="number">1000</span>).toUTCString()&#125;</span>`</span>);</div><div class="line"><span class="comment">//设置过期时间为两分钟后</span></div></pre></td></tr></table></figure><p>在控制台上输出的结果如cache-control的一样</p><h4 id="Last-modified"><a href="#Last-modified" class="headerlink" title="Last-modified"></a>Last-modified</h4><p>服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h2&gt;&lt;p&gt;在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。&lt;/p&gt;
    
    </summary>
    
      <category term="Performance" scheme="http://qinyongli.cn/categories/Performance/"/>
    
    
      <category term="cache" scheme="http://qinyongli.cn/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>新的hexo</title>
    <link href="http://qinyongli.cn/2017/10/18/%E6%96%B0%E7%9A%84hexo/"/>
    <id>http://qinyongli.cn/2017/10/18/新的hexo/</id>
    <published>2017-10-18T13:40:52.000Z</published>
    <updated>2017-10-27T05:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新的博客"><a href="#新的博客" class="headerlink" title="新的博客"></a>新的博客</h1><p>哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，希望能和大家一起分享自己的技术心得，我们一起学习成长。一步一步提高自己的技能点，早日实现自己的技术之梦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新的博客&quot;&gt;&lt;a href=&quot;#新的博客&quot; class=&quot;headerlink&quot; title=&quot;新的博客&quot;&gt;&lt;/a&gt;新的博客&lt;/h1&gt;&lt;p&gt;哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，
      
    
    </summary>
    
      <category term="life" scheme="http://qinyongli.cn/categories/life/"/>
    
    
      <category term="hexo" scheme="http://qinyongli.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
