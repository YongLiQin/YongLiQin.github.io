[{"title":"浅谈JS内存","url":"/2017/10/26/浅谈JS内存/","content":"## 序言\n\n","tags":["Memory"],"categories":["JavaScript"]},{"title":"浅谈curry化","url":"/2017/10/25/浅谈curry化/","content":"\n## 序言\n\n在函数式编程中我了解到了柯里化，并且觉得它很有意思，所以对它的实现原理进行了探索，其中难点还真不少。\n\n<!--more-->\n\n## curry化的概念\n\ncurry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用\n\n## curry化的实现代码\n\n```js\n\nlet sub_curry = function(fn) {\n    let args = [].slice.call(arguments, 1);\n    return function() {\n        return fn.apply(this, args.concat(Array.from(arguments)));\n    };\n};\n\nlet curry = function(fn, len) {\n    len = len || fn.length;\n    return function () {\n        if(arguments.length < len) {\n            let combined = [fn].concat(Array.from(arguments));\n            return curry(sub_curry.apply(this, combined), len - arguments.length);\n        }\n        else {\n            return fn.apply(this, arguments);\n        }\n    };\n};\n```\n\n## curry化使用的哪些知识点\n\n- 闭包\n- 递归\n\n## curry难点解析\n\n难点是下面这句话的调用\n\n```js\n\nsub_curry.apply(this, combined)\n```\n\n这个语句返回一个闭包，并且这个闭包中的fn是前面一个函数。\n\n附上一张图理解。\n\n![](/img/closure.png)\n\n这个最终的目的就是把所有的参数传递给fn调用\n\n附上演示的栗子:\n\n```js\nlet multiply = function (a, b, c) {\n    return a * b * c;\n};\nlet multiplyCurry = curry(multiply);\nconsole.log(multiplyCurry(3)(2)(4));\n//=>24\n```\n\n> 另一种实现\n\n```js\n// 另一种简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n\n    var arity = func.length;\n    var args = args || [];\n\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    }\n}\n```","tags":["FP"],"categories":["JavaScript"]},{"title":"FP-Pointfree编程指南","url":"/2017/10/25/FP-Pointfree编程指南/","content":"\n## 序言\n\n<!--more-->\n\n## Pointfree\n\n### Pointfree概念\n\npointfree 模式指的是，永远不必说出你的数据\n\n不使用所要处理的值，只合成运算过程。\n\nexample\n\n```js\n\nlet compose = function (f, g) {\n    return function (x) {\n        return f(g(x));\n    };\n};\nlet addOne = x => x + 1;\nlet square = x => x * x;\nlet addOneSquare = compose(square, addOne);\naddOneSquare(2);\n//=>9\n```\n\n上面一个栗子，把两个函数组合，然后求值。\n\naddOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。\n\n### Pointfree的本质\n\nPointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。\n\nexample: 读取对象的role属性，不要直接写成obj.role, 而是要把这个操作封装成函数。\n\n```js\n\nlet prop = (p, obj) => obj[p];\nlet propRole = curry(prop)('role');\n```","tags":["FP"],"categories":["JavaScript"]},{"title":"浅谈TCP/IP","url":"/2017/10/21/浅谈TCP-IP/","content":"\n## 序言\n\n作为一名计算机科学与技术的工科生，了解计算机网络基础是必须的。网络通讯遍布在我们身边，从本博客开始，将启航我在计算机网络上的系列学习。\n\n<!--more-->\n\n## OSI七层模型\n\nOSI 模型(开放系统互联模型)是一个由国际标准化组织(ISO)提出概念模型,试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。\n\nOSI　将计算机网络体系结构划分为七层,每层都可以提供抽象良好的接口。了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。\n\n七层协议，从下往上\n\n1. 物理层(网络物理硬件)\n2. 链路层(网络特有的链路接口)\n3. 网络层(IP)\n4. 传输层(TCP/UDP)\n5. 会话层(通信连接/维持会话)\n6. 表示层(加密/解密等)\n7. 应用层(HTTP、SMTP、IMAP等)\n\n附上三个图促进理解\n\n![OSI图片](/img/OSI1.jpg)\n\n![OSI图片](/img/OSI2.gif)\n\n![OSI图片](/img/OSI3.png)\n\n> 物理地址，又称网卡的硬件MAC地址(处于数据链路层)负责局域网通讯，IP地址(处于网络层)负责外网通讯\n\n## TCP/IP\n\n### 定义\n\nTCP/IP模型也被称作DoD模型(Department of Defense Model)。TCP/IP字面上代表了两个协议：TCP（传输控制协议）和IP（网际协议）。但TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族。从协议分层模型方面来讲，TCP/IP由四个层次组成:网络接口层、网络层、传输层、应用层。TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。\n\n> OSI模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去。\n\n> TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n\n> TCP/IP 的设计,是吸取了分层模型的精华思想——封装。每层对上一层提供服务的时候,上一层的数据结构是黑盒,直接作为本层的数据,而不需要关心上一层协议的任何细节\n\n四层模型:\n\n![tcp/ip四层模型图](/img/tipcip&osi.png)\n\n![tcp/ip图片](/img/application.png)\n\nTCP/IP 分层模型的分层以以太网上传输 UDP 数据包如图所示\n\n![tcp/ip图片](/img/TCPIP.png)\n\n各层中的协议\n\n![](/img/protocol.jpg)\n\n![tcpip通讯流](/img/tcpipstream.jpg)\n\n基于tcp的文件传输(ftp－port21)\n\n![](/img/datapackage.png)\n\n基于TCP和UDP的数据封装及解析示例如下：\n\n![](/img/package.jpg)\n\nTCP数据包\n\n![](/img/tcppackage.jpg)\n\ntcp在真正连接前要经过三次握手，断开连接需要经过四次挥手\n\nTCP三次握手\n\n![](/img/threeShake.png)\n\nTCP四次挥手\n\n- 第一次挥手\n\n    主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。\n\n- 第二次挥手\n\n    被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）\n\n- 第三次挥手\n\n    被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了\n\n- 第四次挥手\n\n    主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。\n\n![四次挥手图片](/img/waved.jpg)\n\n\n### IP数据包\n\n以太网数据包(packet)的大小是固定的，最初是1518字节，后来增加到1522字节。其中，1500字节是负载(pyload)，22字节是头部信息(head)。\n\nIP数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以IP数据包的负载最多为1480字节。\n\nIP数据包\n\n![paket数据包](/img/ipPackage.png)\n\n> IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。\n\nTCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。\n\n因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。\n\n![packet数据包](/img/packet2.png)\n\n（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）","tags":["TCP/IP"],"categories":["Internet"]},{"title":"浅谈MVX","url":"/2017/10/21/浅谈MVX/","content":"\n## 序言\n\nMVC框架最早出现在Java领域，然后慢慢的在前端开发中也被提到，后来又出现了MVP，以及现在最成熟的MVVM\n\n<!--more-->\n\n## MVX\n\n### MVC\n\nMVC（Model-View-Controller）是应用最广泛的软件架构之一，一般MVC分为: Model(模型)、Controller(控制器)和View(视图)。这主要是基于分层的目的，让彼此的职责分开。\n\n控制器（Controller），一组行为的集合。(业务逻辑)\n\n模型（Model），数据相关的操作和封装。(数据保存)\n\n视图（View），视图的渲染。(用户界面)\n\nView一般通过Controler来和Model进行联系的。Controller是Model和View的协调者，View和Model不直接联系。基本联系都是单项的。\n\n![](http://image.beekka.com/blog/2015/bg2015020105.png)\n\n1. View 传送指令到Controler\n2. Controller 完成业务逻辑，要求 Model 改变状态\n3. Model 将新的数据发送到　View，用户得到反馈\n\n接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。\n\n![](http://image.beekka.com/blog/2015/bg2015020106.png)\n\n另一种是直接通过controller接受指令。\n\n![](http://image.beekka.com/blog/2015/bg2015020107.png)\n\n### MVP\n\nMVP模式将 Controller改名为Persenter,　同时改变了通信方向。\n\n![](http://image.beekka.com/blog/2015/bg2015020109.png)\n\n1. 各部分之间的通信，都是双向的。\n2. View 与 Model不发生联系。都通过Persenter传递。\n3. View 非常薄, 不部署任何业务逻辑，称为\"被动视图\"，即没有任何主动性，而Persenter非常厚，所有逻辑都部署在那里。\n\n### MVVM\n\nMVVM模式将Persenter改名为ViewModel，基本上与MVP完全一致\n\n![](http://image.beekka.com/blog/2015/bg2015020110.png)\n\n唯一的区别是，它采用双向绑定(data-binding): View的变动，自动反映在ViewModel，反之亦然。Angular和Vue采用这种模式。","tags":["MVX"],"categories":["Architecture"]},{"title":"浅谈Web缓存","url":"/2017/10/19/浅谈Web缓存/","content":"\n## 序言\n\n在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。\n\n<!-- more -->\n\n## 缓存分类\n\n- 数据库缓存\n- 代理服务器缓存\n- CDN缓存\n- 浏览器缓存\n\n### 浏览器缓存\n\n页面的缓存状态是由header决定的，header的参数有四种。\n\n#### Cache-Control\n\n其优先级要比Expires高\n\n- max-age\n\n\t单位为s，指定设置缓存最大的有效时间，定义时间的长短。当浏览器向服务器发送请求过后，在max-age这段时间里浏览器就不会再向服务器发送请求了。\n\n\texample\n\n\t```js\n\n    const http = require('http');\n    const fs = require('fs');\n    const port = 3000;\n    const host = '127.0.0.1';\n    const server = http.createServer();\n    server.on('request', (req, res) => {\n        if(req.url == '/') {\n            console.log(req.url);\n            fs.readFile('./index.html', (err, data) => {\n                res.statusCode = 200;\n                res.setHeader('Content-Type', 'text/html');\n                //设置Cache-Control缓存\n                res.setHeader('Cache-Control', 'max-age=60');\n                res.end(data);\n            });\n        }\n    });\n    server.listen(port, host, () => {\n        console.log(`server serve at http://${host}:${port}`);\n    });\n    ```\n\n    在firefox输入网址后回车，然后在地址栏再次回车。控制台输入的结果如图\n\n    ![](/img/cache-control1.png)\n\n    一次请求\n\n    不设置缓存，控制输入的结果如图\n\n    ![](/img/cache-control2.png)\n\n    两次请求\n\n- s-maxage\n\n    单位为s，同max-age，只是用于共享缓存(比如CDN缓存)\n\n    比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通的缓存，而s-maxage用于代理缓存。\n    如果存在s-maxage，则会覆盖掉max-age和Expires header\n\n- public\n\n    指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定public还是private，则默认为public\n\n- private\n\n    响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private\n\n- no-cache\n\n    指定不缓存响应\n\n    ```js\n\n    res.setHeader('Cache-Control', 'no-cache');\n    ```\n\n    设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间\n\n- no-store\n\n    绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存，每次请求资源都要从服务器重新获取\n\n#### Expires\n\n单位为毫秒ms，缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\n\n```js\n\nres.setHeader('Expires', `${new Date(Date.now() + 60 * 2 * 1000).toUTCString()}`);\n//设置过期时间为两分钟后\n```\n\n在控制台上输出的结果如cache-control的一样\n\n#### Last-modified\n\n服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。\n\n#### ETag\n\n根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下","tags":["cache"],"categories":["Performance"]},{"title":"新的hexo","url":"/2017/10/18/新的hexo/","content":"\n# 新的博客\n\n哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，希望能和大家一起分享自己的技术心得，我们一起学习成长。一步一步提高自己的技能点，早日实现自己的技术之梦。","tags":["hexo"],"categories":["life"]}]