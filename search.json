[{"title":"浅谈HTTP","url":"/2017/10/30/浅谈HTTP/","content":"## 序言\n\n作为一个WEB开发者，了解一些常用的协议是必须的，本编将总结自己在协议方面的学习。\n\n<!--more-->\n\n## WEB始祖HTTP\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如TCP建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。\n\nHTTP得以发展是W3C和IETF两个组织和作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。\n\n## HTTP的基本优化\n\n影响一个HTTP网络请求的因素主要有两个: 宽带和延迟。\n\n宽带: 如果说我们还停留在拨号上网的阶段，宽带可能成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得宽带得到极大的提升，我们就不再会担心有宽带而影响网速了。\n\n延迟: \n- 浏览器阻塞(HOL blocking):　浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有4个连接(这个根据浏览器内核不同可能会有所差异)，超过浏览器最大连接限制，后续请求就会被阻塞。\n- DNS查询(DNS Lookup): 浏览器需要知道目标服务器的IP才能建立连接。将域名解析为IP的这个系统就是DNS。这个通常可以利用DNS缓存结果达到减少这个时间的目的。\n- 建立连接(initial connection): HTTP是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较为明显，慢启动则对文件类大请求影响较大。\n\n## HTTP1.0与HTTP1.1\n\n最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用在现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。主要区别体现在:\n\n### 区别\n\n1. 缓存处理，HTTP1.0中主要使用header里的If-Modified-Since，Expires来作为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，例如Entity，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。\n2. 宽带优化及网络连接的使用，HTTP1.0中，存在浪费宽带的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码206(Partial Content)，这样就方便了开发者自由的选择以便于充分选择利用宽带和连接。\n3. 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409(Conflict)表示服务器上的某个资源被永久性的删除。\n4. 长连接，HTTP1.1支持长连接和请求流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keey-alive，一定程度上弥补了HTTP1.O每次请求都要创建连接的缺点。\n5. Host头处理，在HTTP1.0中认为每一台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名(hostname)。但随着虚拟机技术的发展，在一台物理服务器上可以存在多个虚拟机，并且他们共享一个IP地址。HTTP1.1中的请求消息和响应消息都应该支持Hose头域，且请求消息中如果没有Host头域会报告一个错误(440 Bad Request)。\n\n### 问题\n\n1. HTTP1.0在传输数据时，每次都要重新建立连接，无疑增加了大量的延迟时间，特别是移动端表现更为突出。\n2. HTTP1.x在传输数据时，所有传输的内容都是明文的，无法保证数据的安全性。\n3. HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户的流量。\n4. 虽然HTTP1.x支持keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用同样会给服务器端带来大量的性能压力，并且对于单个文件被不断请求的服务（例如图片存放网站），keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。\n\n## HTTP\n\nHTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\nHTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。\n\nHTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n### HTTP 消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![](/img/httprequest.png)\n\n#### 服务器响应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![](/img/httpmessage.jpg)\n\n#### 实例\n\n客户端请求：\n\n```js\n> GET / HTTP/1.1\n> Host: localhost:3000\n> User-Agent: curl/7.47.0\n> Accept: */*\n> \n```\n\n服务端响应:\n```js\n< HTTP/1.1 200 OK\n< Content-Type: text/plain\n< Date: Tue, 31 Oct 2017 14:11:22 GMT\n< Connection: keep-alive\n< Transfer-Encoding: chunked\n< \nHello World\n```\n\n### HTTP请求方法\n\n- GET: 最常用的方法，通常用于请求服务器发送某个资源。\n- POST: 起初是用来向服务器输入数据，实际上通常用来把表单数据传输到服务器。\n- PUT: 与GET从服务器读取文档相反，PUT方法会向服务器写入文档。\n- DELETE: 请求服务器删除指定的资源。\n\n### HTTP状态码\n\nHTTP状态码:\n\n- 200 - 请求成功\n- 301 - 资源（网页等）被永久转移到其它URL\n- 404 - 请求的资源（网页等）不存在\n- 500 - 内部服务器错误\n\nHTTP状态码分类: \n\n- 1**\t信息，服务器收到请求，需要请求者继续执行操作\n- 2**\t成功，操作被成功接收并处理\n- 3**\t重定向，需要进一步的操作以完成请求\n- 4**\t客户端错误，请求包含语法错误或无法完成请求\n- 5**\t服务器错误，服务器在处理请求的过程中发生了错误\n\n### http模块\n\nNode的http模块包含了对HTTP处理的封装。在Node中，HTTP服务继承了TCP服务器(net模块)，它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装。\n\n![](/img/http.png)\n\nhttp模块将connection到request的过程进行了封装\n\n除此之外，http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿出连接中的传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头，触发request事件，调用用户的业务逻辑。该逻辑的示意图:\n\n![](/img/theprocessofhttp.png)\n\n#### HTTP请求\n\n对TCP连接的读操作，http模块将其封装为ServerRequest对象。请求报文头部将会通过http_parser进行解析。\n\n报头被解析后放置在req.headers属性上传递给业务逻辑以供调用。\n\n报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作，如下所示: \n\n```js\n(req, res) => {\n    //console.log(req.headers);\n    let buffers = [];\n    req.on('data', chunk => {\n        buffers.push(chunk);\n    });\n    res.on('end', () => {\n        let buffer = Buffer.concat(buffers);\n        res.end('Hello World');\n    });\n};\n```\nHTTP请求对象和HTTP响应对象是相对较底层的封装，现行的Web框架express就是在这两个对象的基础上进行高层封装完成的。\n\n#### HTTP响应\n\nHTTP响应封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的API为res.setHeader()和res.writeHead()。在上述报文示例中:\n\n```js\nres.writeHead(200, {'Content-Type': 'text/plain'});\n```\n\n其分为setHeader()和writeHead()两个步骤。它在http模块的封装下，实际生成如下的报文: \n\n```js\n< HTTP/1.1 200 OK\n< Content-Type: text/plain\n```\n\n我们可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中。除此之外，http模块会自动帮你设置一些头信息，如下所示:\n\n```js\n< Date: Tue, 31 Oct 2017 14:11:22 GMT\n< Connection: keep-alive\n< Transfer-Encoding: chunked\n<\n```\n\n响应结束后，HTTP服务器将可能会将当前连接用于下一个请求，或者关闭连接。值得注意的是，报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不会再生效。这有协议的特性决定的。\n\n### HTTP服务器\n\n```js\nconst http = require('http');\nconst server =  http.createServer((req, res) => {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello World\\n');\n});\nserver.listen(8080, '127.0.0.1', () => {\n    console.log('server runing at http://localhost:127.0.0.1:1337/');\n});\n```\nNODE获取客户端IP:\n\n```js\nreq.headers['x-forwarded-for'] || req.connection.remoteAddress || req.socket.remoteAddress;\n```\n\nNODE获取客户端PORT:\n```js\nreq.connection.remotePort || req.socket.remotePort;\n```\n\n#### HTTP服务器的事件\n\n如同TCP服务一样，HTTP服务器也抽象了一些事件，以供应用层使用，同样典型的是，服务器也是一个EventEmitter实例。\n\n- connection事件: 在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接有可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。\n\n- request事件: 建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。\n\n- close事件: 与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以server.close()传递一个回调函数来快速注册该事件。\n\n- connect事件: 当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起请求的连接将会关闭。\n\n- upgrade事件: 当客户端要求升级连接协议时，需要和服务器协商，客户端会在请求头中带上Upgrade字段，服务器端会在接受到这样的请求时触发该事件。如果不监听该事件，发起该请求的连接将会被关闭。\n\n- clientError事件: 连接的客户触发error事件时，这个错误会传递到服务器端，此时触发该事件。\n\n### HTTP客户端\n\n> 从协议的角度来说，现在的应用，如浏览器，其实是一个HTTP的代理，用户的行为将会通过它转化为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上。HTTP服务只做两件事情: 处理HTTP请求和发送HTTP响应。\n\nhttp模块提供了一个底层API: http.request(options, connect)，用于构造HTTP客户端。\n\n```js\nconst options = {\n    hostname: '127.0.0.1',\n    port: 1334,\n    path: '/',\n    method: 'GET'\n};\nconst req = http.request(options, res => {\n    console.log('STATUS: ' + res.statusCode);\n    console.log('HEADERS: ' + JSON.stringify(res.headers));\n    res.setEncoding('uft8');\n    res.on('data', chunk => {\n        console.log(chunk);\n    });\n});\nreq.end();\n```\n\noptions参数决定了这个HTTP请求头中的内容，它的选项有如下这些。\n\n- host: 服务器的域名或IP地址，默认为localhost。\n- hostname: 服务器名称。\n- port: 服务器端口，默认为80。\n- socketPath: Domain套接字路径。\n- method: HTTP请求方法，默认为GET。\n- path: 请求路径，默认为/。\n- headers: 请求头对象。\n- auth: Basic认证，这个值将被计算成请求头中的Authorization部分。\n\n#### 客户端事件:\n\n- response: 与服务端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。\n- socket: 当底层连接池中建立的连接分配给当前请求对象时，触发该事件。\n- connect: 当客户端向服务器端发起CONNECT请求时，如果服务器响应了200状态码，客户端将会触发该事件。\n- upgrade: 客户端向服务器端发起Upgrade请求时，如果服务器响应了101 Switching Protocols状态，客户端将会触发该事件。\n- continue: 客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件。 \n\n> 在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完就触发response事件，同时传递一个响应对象以供操作ClientResponse。\n\n> TCP和UDP都属于网络传输协议，如果要构造高效的网络应用，就应该从传输层进行着手。\n","tags":["HTTP"],"categories":["NODEJS"]},{"title":"TCP、UDP、Socket总结","url":"/2017/10/28/TCP、UDP、Socket总结/","content":"\n## 序言\n\n本篇将开启我对各种协议的理解总结。\n\n<!--more-->\n\n## UDP与TCP与Socket\n\n### Socket\n\n#### 定义\n\n网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。\n\nSocket的英文原义是\"孔\"或\"插座\"。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作\"套接字\"，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。\n\nsocket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\n![](/img/socket.jpg)\n\n#### Server-Client模型\n\n服务器，使用ServerSocket监听指定的端口，端口可以随意指定（由于1024以下的端口通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于1024的端口），等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。\n\n客户端，使用Socket对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话完成后，关闭Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个1024以上的端口。\n\nSocket接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。要学Internet上的TCP/IP网络编程，必须理解Socket接口。Socket接口设计者最先是将接口放在Unix操作系统里面的。如果了解Unix系统的输入和输出的话，就很容易了解Socket了。网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用Socket（），该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。\n\n![](/img/socket.png)\n\n#### 常用的套接字类型2中折叠常用的Socket类型\n\n- 流式套接字（SOCK_STREAM）：面向连接的Socket，针对于面向连接的TCP服务应用。\n- 数据报式套接字（SOCK_DGRAM）：无连接的Socket，对应于无连接的UDP服务应用。\n\n### TCP\n\nTCP服务在网络应用中十分常见，目前大多数的应用都是基于TCP搭建而成。典型的HTTP、SMTP、IMAP等协议。\n\nTCP(传输控制协议)是面向连接的、传输可靠（保证数据正确性且保证数据顺序）、用于传输大量数据（流模式）、速度快，建立连接需要开销多（时间、系统资源）。\n\n#### TCP服务器端\n\n```js\nconst net = require('net');\nconst server = net.createServer(socket => {\n    socket.on('data', data => {\n        console.log(`接受到客户端发来的数据: ${data}`);\n        socket.write('你好');\n    });\n    socket.on('end', () => {\n        console.log('断开链接');\n    });\n    socket.write('欢迎光临nodejs应用\\n');\n});\nserver.listen(8124, () => {\n    console.log('server bound');\n});\n```\n\n#### TCP客户端\n\n```js\nconst net = require('net');\nconst client = net.connect({port: 8124}, () => {\n    console.log('client connected');\n    client.write('Hello World!');\n});\nclient.on('data', data => {\n    console.log(data.toString());\n    client.end();\n});\nclient.on('end',() => {\n    console.log('client disconnected');\n});\n```\n\n#### TCP服务事件\n\n##### 服务器事件\n\n对于通过net.createServer()创建的服务器而言，它是一个EventEmiter实例，它的自定以事件有如下几种。\n\n- listening: 在调用server.listen()绑定端口或Domain Socket后触发。\n- connection: 每个客户端套接字连接到服务器端时触发。\n- close:　当服务器关闭时触发, 在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。\n- error: 当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常。\n\n##### 连接事件\n\n服务器可以同时与多个客户端保持连接，对于每一个连接而言是典型的可写可读Stream对象。Stream对象可以用于服务器和客户端之间的通信，既可以通过data事件从一端读取另一端发来的数据，也可以通过write()方法从一端向另一端发送数据。它具有如下的自定义事件。\n\n- data: 当一端调用write()发送数据时，另一端将会触发data事件，事件传递的数据即是write()发送的数据。\n- end: 当连接中的任意一端发送了FIN数据时，将会触发该事件。\n- connect: 该事件用于客户端，当套接字与服务器端连接成功时会被触发。\n- drain: 当任意一端调用write()发送数据时，当前这段会触发该事件。\n- error: 当异常发生时，触发该事件。\n- timeout: 当一定事件后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置。\n\n另外，由于TCP套接字是可读可写的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器:\n```js\nconst net = require('net');\nconst server = net.createServer(socket => {\n    socket.write('Echo server \\r\\n');\n    socket.pipe(socket);\n});\nserver.listen(1337, '127.0.0.1');\n```\n\n### UDP\n\nUDP(用户数据包协议)面向非连接、传输不可靠、用于传输少量数据（数据报模式）、速度快，UDP传输的可靠性由应用层负责。\n\nUDP报头: \n\n![](https://p1.ssl.qhmsg.com/dr/220__/t013b598635950ce8ea.png)\n\nTCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通讯，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通讯，它虽然提供面向事务的简单不可靠的信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，如果音频、视频等。UDP目前应用很广泛，DNS服务器是基于它实现的。\n\n#### 创建UDP套接字\n\n创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接受数据。\n\n```js\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n```\n\n####　创建UDP服务器端\n\n若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可。以下为一个完整的服务器端示例:\n\n```js\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('message', (msg, rinfo) => {\n    console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\nserver.on('listening', () => {\n    let address = server.address();\n    console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind(41234);\n```\n\n该套接字将接收所有网卡上41234端口上的消息。在绑定完成后，将触发listening事件。\n\n#### 创建UDP客户端\n\n创建一个客户端与服务器端进行对话，代码如下：\n\n```js\nconst dgram = require('dgram');\nconst message = new Buffer(\"深入浅出nodejs\");\nconst client = dgram.createSocket('udp4');\nclient.send(message, 0, message.length, 41234, 'localhost', (err, bytes) => {\n    client.close();\n});\n```\n\n当套接字对象用在客户端时，可以调用send()方法发送消息到网络中。send()方法的参数如下:\n\n```js\nsocket.send(buf, offset, length, port, address, [callback]);\n```\n\n这些参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调。与TCP套接字的write相比,send()方法的参数列表相对复杂，但是它更灵活的地方在于可以随意发送数据到网络中的服务器端，而TCP如果要发送数据给另一个服务器端，则需要重新通过套接字构造新的连接。\n\n#### UDP套接字事件\n\nUDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream实例。它具备如下自定义事件:\n\n- message: 当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址消息。\n- listening: 当UDP套接字开始侦听时触发该事件。\n- close: 调用close()方法时触发该事件，并不在触发message事件。如需再次触发message事件，重新绑定即可。\n- error: 当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。","tags":["Protocol"],"categories":["Internet"]},{"title":"JavaScript常用设计模式","url":"/2017/10/28/JavaScript常用设计模式/","content":"\n## 序言\n\n模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的JavaScript应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。\n\n<!-- more-->\n\n## 常用的设计模式\n\n- 工厂模式\n- 单体模式\n- 模块模式\n- 代理模式\n- 职责链模式\n- 命令模式\n- 模板方法模式\n- 策略模式\n- 发布-订阅模式\n- 中介者模式\n\n### 工厂模式\n\n工厂模式是为了解决多个类似的对象声明的问题，也就是为了解决实例化对象产生的重复问题。\n\n```js\nfunction CreatePerson(name, age, sex) {\n    let obj = new Object();\n    obj.name = name;\n    obj.age = age;\n    obj.sex = sex;\n    obj.sayName = function () {\n        return this.name;\n    };\n    return obj;\n};\n\nlet person1 = new CreatePerson('xiaowang', '20', 'boy');\nlet person2 = new CreatePerson('mary', '18', 'girl');\nconsole.log(person1.name);//xiaowang\nconsole.log(person2.name);//may\n\n//返回都是object，无法识别对象的类型，不知道他们是哪个对象的实例。\nconsole.log(typeof person1);//object\nconsole.log(typeof person2);//object\nconsole.log(person1 instanceof Object);//true\n```\n\n> 优点: 能解决多个相似的问题\n> 缺点: 不能知道对象识别的问题(对象的类型不知道)\n\n### 单体模式\n\n单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象。如果它可以被实例化，那么它只能被实例化一次。\n\n对象字面量来创建单体模式\n\n```js\nlet Singleton = {\n    attr1: 1,\n    attr2: 2,\n    method1: function () {\n        return this.attr1;\n    },\n    method2: function () {\n        return this.attr2;\n    }\n};\n```\n\n单体化模式\n\n```js\nlet Singleton = function (name) {\n    this.name = name;\n};\nSingleton.prototype.getName = function () {\n    return this.name;\n};\nlet getInstance = (function () {\n    let instance = null;\n    return function (name) {\n        if(!instance) {\n            instance = new Singleton(name);\n        }\n        return instance;\n    }\n})();\nlet a = getInstance('aa');\nlet b = getInstance('bb');\nconsole.log(a == b);//true\nconsole.log(a.getName());//aa\nconsole.log(b.getName());//aa\n```\n\n单体模式的优点:\n\n- 可以来用划分命令空间，减少全局变量。\n- 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。\n\n### 模块模式\n\n模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用。\n\n```js\nlet Single = (function () {\n    //私有变量\n    let privateNum = 112;\n    //公有变量\n    let publicNum = 110;\n    //私有函数\n    function privateFunc() {\n        //业务逻辑代码\n    };\n    //公有函数\n    function publicFunc() {\n        //业务逻辑代码\n    }；\n    //返回一个对象包含公有方法和属性\n    return {\n        publicNum,\n        publicFunc\n    };\n});\n```\n\n### 代理模式\n\n```js\n//声明一个妹子\nlet AGirl = function (name) {\n    this.name = name;\n};\n//声明一个男孩\nlet ABoy = function (girl) {\n    this.girl = girl;\n    //送礼物给一个妹子\n    this.sendMarriageGift = function (gift) {\n        return 'Hi ' + this.girl.name + ', a　boy 送你一个礼物: ' + gift;\n    };\n};\n//代理人\nlet Proxy = function (girl) {\n    this.girl = girl;\n    this.sendGift = function (gift) {\n        new ABoy(girl).sendMarriageGift(gift);\n    };\n};\n//初始化\nlet proxy = new Proxy(new AGirl('漂亮妹子'));\nproxy.sendGift('结婚戒');//Hi 漂亮妹子, a boy 送你一个礼物：　结婚戒\n```","tags":["设计模式"],"categories":["JavaScript"]},{"title":"浅谈JS内存","url":"/2017/10/26/浅谈JS内存/","content":"## 序言\n\n与前端不同，后端是直面服务器的，所以对性能的要求更高，对内存有更高的要求。如果存在内存泄漏，跟随着时间的流逝，内存泄漏越来越多，程序运行也会越来越慢，最终崩溃。所以要想深入学习node，控制内存的使用是至关重要的。\n\n","tags":["Memory"],"categories":["JavaScript"]},{"title":"浅谈curry化","url":"/2017/10/25/浅谈curry化/","content":"\n## 序言\n\n在函数式编程中我了解到了柯里化，并且觉得它很有意思，所以对它的实现原理进行了探索，其中难点还真不少。\n\n<!--more-->\n\n## curry化的概念\n\ncurry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用\n\n## curry化的实现代码\n\n```js\nlet sub_curry = function(fn) {\n    let args = [].slice.call(arguments, 1);\n    return function() {\n        return fn.apply(this, args.concat(Array.from(arguments)));\n    };\n};\nlet curry = function(fn, len) {\n    len = len || fn.length;\n    return function () {\n        if(arguments.length < len) {\n            let combined = [fn].concat(Array.from(arguments));\n            return curry(sub_curry.apply(this, combined), len - arguments.length);\n        }\n        else {\n            return fn.apply(this, arguments);\n        }\n    };\n};\n```\n\n## curry化使用的哪些知识点\n\n- 闭包\n- 递归\n\n## curry难点解析\n\n难点是下面这句话的调用\n\n```js\nsub_curry.apply(this, combined)\n```\n\n这个语句返回一个闭包，并且这个闭包中的fn是前面一个函数。\n\n附上一张图理解。\n\n![](/img/closure.png)\n\n这个最终的目的就是把所有的参数传递给fn调用\n\n附上演示的栗子:\n\n```js\nlet multiply = function (a, b, c) {\n    return a * b * c;\n};\nlet multiplyCurry = curry(multiply);\nconsole.log(multiplyCurry(3)(2)(4));\n//=>24\n```\n\n> 另一种实现\n\n```js\n// 另一种简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n    var arity = func.length;\n    var args = args || [];\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    };\n};\n```","tags":["FP"],"categories":["JavaScript"]},{"title":"FP-Pointfree编程指南","url":"/2017/10/25/FP-Pointfree编程指南/","content":"\n## 序言\n\n<!--more-->\n\n## Pointfree\n\n### Pointfree概念\n\npointfree 模式指的是，永远不必说出你的数据\n\n不使用所要处理的值，只合成运算过程。\n\nexample\n\n```js\nlet compose = function (f, g) {\n    return function (x) {\n        return f(g(x));\n    };\n};\nlet addOne = x => x + 1;\nlet square = x => x * x;\nlet addOneSquare = compose(square, addOne);\naddOneSquare(2);\n//=>9\n```\n\n上面一个栗子，把两个函数组合，然后求值。\n\naddOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。\n\n### Pointfree的本质\n\nPointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。\n\nexample: 读取对象的role属性，不要直接写成obj.role, 而是要把这个操作封装成函数。\n\n```js\nlet prop = (p, obj) => obj[p];\nlet propRole = curry(prop)('role');\n```","tags":["FP"],"categories":["JavaScript"]},{"title":"浅谈TCP/IP","url":"/2017/10/21/浅谈TCP-IP/","content":"\n## 序言\n\n作为一名计算机科学与技术的工科生，了解计算机网络基础是必须的。网络通讯遍布在我们身边，从本博客开始，将启航我在计算机网络上的系列学习。\n\n<!--more-->\n\n## OSI七层模型\n\nOSI 模型(开放系统互联模型)是一个由国际标准化组织(ISO)提出概念模型,试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。\n\nOSI　将计算机网络体系结构划分为七层,每层都可以提供抽象良好的接口。了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。\n\n七层协议，从下往上\n\n1. 物理层(网络物理硬件)\n2. 链路层(网络特有的链路接口)\n3. 网络层(IP)\n4. 传输层(TCP/UDP)\n5. 会话层(通信连接/维持会话)\n6. 表示层(加密/解密等)\n7. 应用层(HTTP、SMTP、IMAP等)\n\n附上三个图促进理解\n\n![OSI图片](/img/OSI1.jpg)\n\n![OSI图片](/img/OSI2.gif)\n\n![OSI图片](/img/OSI3.png)\n\n> 物理地址，又称网卡的硬件MAC地址(处于数据链路层)负责局域网通讯，IP地址(处于网络层)负责外网通讯\n\n## TCP/IP\n\n### 定义\n\nTCP/IP模型也被称作DoD模型(Department of Defense Model)。TCP/IP字面上代表了两个协议：TCP（传输控制协议）和IP（网际协议）。但TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族。从协议分层模型方面来讲，TCP/IP由四个层次组成:网络接口层、网络层、传输层、应用层。TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。\n\n> OSI模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去。\n\n> TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n\n> TCP/IP 的设计,是吸取了分层模型的精华思想——封装。每层对上一层提供服务的时候,上一层的数据结构是黑盒,直接作为本层的数据,而不需要关心上一层协议的任何细节\n\n四层模型:\n\n![tcp/ip四层模型图](/img/tipcip&osi.png)\n\n![tcp/ip图片](/img/application.png)\n\nTCP/IP 分层模型的分层以以太网上传输 UDP 数据包如图所示\n\n![tcp/ip图片](/img/TCPIP.png)\n\n各层中的协议\n\n![](/img/protocol.jpg)\n\n![tcpip通讯流](/img/tcpipstream.jpg)\n\n基于tcp的文件传输(ftp－port21)\n\n![](/img/datapackage.png)\n\n基于TCP和UDP的数据封装及解析示例如下：\n\n![](/img/package.jpg)\n\nTCP数据包\n\n![](/img/tcppackage.jpg)\n\ntcp在真正连接前要经过三次握手，断开连接需要经过四次挥手\n\nTCP三次握手\n\n![](/img/threeShake.png)\n\nTCP四次挥手\n\n- 第一次挥手\n\n    主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。\n\n- 第二次挥手\n\n    被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）\n\n- 第三次挥手\n\n    被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了\n\n- 第四次挥手\n\n    主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。\n\n![四次挥手图片](/img/waved.jpg)\n\n\n### IP数据包\n\n以太网数据包(packet)的大小是固定的，最初是1518字节，后来增加到1522字节。其中，1500字节是负载(pyload)，22字节是头部信息(head)。\n\nIP数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以IP数据包的负载最多为1480字节。\n\nIP数据包\n\n![paket数据包](/img/ipPackage.png)\n\n> IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。\n\nTCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。\n\n因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。\n\n![packet数据包](/img/packet2.png)\n\n（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）","tags":["TCP/IP"],"categories":["Internet"]},{"title":"浅谈MVX","url":"/2017/10/21/浅谈MVX/","content":"\n## 序言\n\nMVC框架最早出现在Java领域，然后慢慢的在前端开发中也被提到，后来又出现了MVP，以及现在最成熟的MVVM\n\n<!--more-->\n\n## MVX\n\n### MVC\n\nMVC（Model-View-Controller）是应用最广泛的软件架构之一，一般MVC分为: Model(模型)、Controller(控制器)和View(视图)。这主要是基于分层的目的，让彼此的职责分开。\n\n控制器（Controller），一组行为的集合。(业务逻辑)\n\n模型（Model），数据相关的操作和封装。(数据保存)\n\n视图（View），视图的渲染。(用户界面)\n\nView一般通过Controler来和Model进行联系的。Controller是Model和View的协调者，View和Model不直接联系。基本联系都是单项的。\n\n![](http://image.beekka.com/blog/2015/bg2015020105.png)\n\n1. View 传送指令到Controler\n2. Controller 完成业务逻辑，要求 Model 改变状态\n3. Model 将新的数据发送到　View，用户得到反馈\n\n接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。\n\n![](http://image.beekka.com/blog/2015/bg2015020106.png)\n\n另一种是直接通过controller接受指令。\n\n![](http://image.beekka.com/blog/2015/bg2015020107.png)\n\n### MVP\n\nMVP模式将 Controller改名为Persenter,　同时改变了通信方向。\n\n![](http://image.beekka.com/blog/2015/bg2015020109.png)\n\n1. 各部分之间的通信，都是双向的。\n2. View 与 Model不发生联系。都通过Persenter传递。\n3. View 非常薄, 不部署任何业务逻辑，称为\"被动视图\"，即没有任何主动性，而Persenter非常厚，所有逻辑都部署在那里。\n\n### MVVM\n\nMVVM模式将Persenter改名为ViewModel，基本上与MVP完全一致\n\n![](http://image.beekka.com/blog/2015/bg2015020110.png)\n\n唯一的区别是，它采用双向绑定(data-binding): View的变动，自动反映在ViewModel，反之亦然。Angular和Vue采用这种模式。","tags":["MVX"],"categories":["Architecture"]},{"title":"浅谈Web缓存","url":"/2017/10/19/浅谈Web缓存/","content":"\n## 序言\n\n在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。\n\n<!-- more -->\n\n## 缓存分类\n\n- 数据库缓存\n- 代理服务器缓存\n- CDN缓存\n- 浏览器缓存\n\n### 浏览器缓存\n\n页面的缓存状态是由header决定的，header的参数有四种。\n\n#### Cache-Control\n\n其优先级要比Expires高\n\n- max-age\n\n\t单位为s，指定设置缓存最大的有效时间，定义时间的长短。当浏览器向服务器发送请求过后，在max-age这段时间里浏览器就不会再向服务器发送请求了。\n\n\texample\n\n\t```js\n    const http = require('http');\n    const fs = require('fs');\n    const port = 3000;\n    const host = '127.0.0.1';\n    const server = http.createServer();\n    server.on('request', (req, res) => {\n        if(req.url == '/') {\n            console.log(req.url);\n            fs.readFile('./index.html', (err, data) => {\n                res.statusCode = 200;\n                res.setHeader('Content-Type', 'text/html');\n                //设置Cache-Control缓存\n                res.setHeader('Cache-Control', 'max-age=60');\n                res.end(data);\n            });\n        }\n    });\n    server.listen(port, host, () => {\n        console.log(`server serve at http://${host}:${port}`);\n    });\n    ```\n\n    在firefox输入网址后回车，然后在地址栏再次回车。控制台输入的结果如图\n\n    ![](/img/cache-control1.png)\n\n    一次请求\n\n    不设置缓存，控制输入的结果如图\n\n    ![](/img/cache-control2.png)\n\n    两次请求\n\n- s-maxage\n\n    单位为s，同max-age，只是用于共享缓存(比如CDN缓存)\n\n    比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通的缓存，而s-maxage用于代理缓存。\n    如果存在s-maxage，则会覆盖掉max-age和Expires header\n\n- public\n\n    指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定public还是private，则默认为public\n\n- private\n\n    响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private\n\n- no-cache\n\n    指定不缓存响应\n\n    ```js\n    res.setHeader('Cache-Control', 'no-cache');\n    ```\n\n    设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间\n\n- no-store\n\n    绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存，每次请求资源都要从服务器重新获取\n\n#### Expires\n\n单位为毫秒ms，缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\n\n```js\nres.setHeader('Expires', `${new Date(Date.now() + 60 * 2 * 1000).toUTCString()}`);\n//设置过期时间为两分钟后\n```\n\n在控制台上输出的结果如cache-control的一样\n\n#### Last-modified\n\n服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。\n\n#### ETag\n\n根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改，如果没有修改，过程如下","tags":["cache"],"categories":["Performance"]},{"title":"新的hexo","url":"/2017/10/18/新的hexo/","content":"\n# 新的博客\n\n哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，希望能和大家一起分享自己的技术心得，我们一起学习成长。一步一步提高自己的技能点，早日实现自己的技术之梦。","tags":["hexo"],"categories":["life"]}]