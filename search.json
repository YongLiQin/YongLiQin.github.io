[{"title":"HTML5的新API","url":"/2019/04/18/HTML5的新API/","content":"\n## 序言\n\nHTML5出现了很多新的API，而在这里我总结了两个可能会使用到的api，requestAnimationFrame、MutationObserver。\n\n<!-- more -->\n\n## requestAnimationFrame\n\n### 基本概念\n\nrequestAnimationFrame方法用于以一种更好的性能来实现动画。\n\n通过window.requestAnimationFrame方法，浏览器可以具有将各种并发性动画结合入一个单一的页面进行创建及渲染的能力，这种能力将使得动画的实现具有更好的性能。当用户将浏览器标签切换到其他标签窗口时，当前页面中的动画将被暂停运行，以减少CPU、GPU与内存的消耗。\n\nwindow.requestAnimationFrame方法告诉浏览器希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。它采用系统时间间隔，保持最佳的绘制效率，不会因为时间间隔过短，造成过度绘制，增加开销；也不会因为间隔太长，使动画卡顿不流畅\n\n### 使用示例\n\n```html\n<div class=\"box\"></div>\n<script type=\"text/javascript\">\n    let height = 2;\n    function change () {\n        const box = document.querySelector('.box');\n        height += 2;\n        box.style.height = height + 'px';\n        if (height <= 600) {\n            loop();\n        }\n    }\n    function loop() {\n        requestAnimationFrame(change);\n    }\n    loop();\n</script>\n```\n\n### 优势\n\n- 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。\n- 在隐藏或不可见的元素中，将不会进行重绘或回流\n- 页面不激活状态下，进入睡眠状态，暂停动画运行。\n\n## Mutation Observer\n\nMutationObserver api的出现是为了检测页面变化。\n\n我们首先需要创建MutationObserver对象，创建方法如下所示：\n\n```js\nfunction onchange(mutationRecords, mutationObserver) {\n\tconsole.log('检测到动画变化');\n}\n\nvar mo = new MutationObserver(onchange);\n```\n\nMutationOberver对象的构造函数使用一个参数，参数值为当检测到页面变化时所需执行的函数，该函数又使用两个参数，第一个参数值为包含页面变化时所产生的一系列信息的数组，第二个参数值为被调用的MutationObserver对象实例。\n\n需要调用MutationObserver实例的observer方法进行检测。\n\n使用示例:\n\n```html\n<div id=\"mutation\">mutation</div>\n<button id=\"btn\">change</button>\n<script>\n    const mutation = document.querySelector('#mutation');\n    const btn = document.querySelector('#btn');\n    btn.onclick = function () {\n        if (mutation.style.color == 'red') {\n            mutation.style.color = 'inherit';\n        } else {\n            mutation.style.color = 'red';\n        }\n        \n    }\n    const options = {\n        attributes: true\n    };\n    const mo = new MutationObserver((mutationRecords) => {\n        console.log(mutationRecords);\n    });\n    mo.observe(mutation, options);\n</script>\n```\n\nMutationObserver对象的observer方法使用两个参数，其中一个参数值为被观察的目标节点，第二参数值为观察时所使用的各种选项。\n\noptions:\n\n- attributes 是否观察目标节点的所有属性\n- characterData 是否观察目标节点的子文字节点\n- childList 是否观察目标节点的子节点\n\n\n\n","tags":["HTML5"]},{"title":"探索flex","url":"/2019/04/16/探索flex/","content":"\n\n## 序言\n\n布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中、多列布局底部持平就不容易实现。\n\nW3C提出了一种新的方案—-Flex布局(也就是弹性布局)，可以简便、完整、响应式地实现各种页面布局。\n\n<!-- more -->\n\n## 基本概念\n\n采用Flex布局的元素，称为Flex容器，简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。\n\n![flex-container](/img/flex-container.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n## 容器的属性\n\n- flex-direction\n- flex-wrap\n- flex-flow\n- justify-content\n- align-items\n- align-content\n\n### flex-direction属性\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n```css\n.box {\n\tflex-direction: row | row-reverse | column | column-reverse;\n}\n```\n\n![flex-direction](/img/flex-direction.png)\n\n它有4个值。\n\n- row（默认值）：主轴为水平方向，起点在左端。\n- row-reverse：主轴为水平方向，起点在右端。\n- column：主轴为垂直方向，起点在上沿。\n- column-reverse：主轴为垂直方向，起点在下沿。\n\n### flex-wrap属性\n\n默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n\n![flex-wrap](/img/flex-wrap.png)\n\n```css\n.box{\n\tflex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n\n它有3个值。\n\n- nowrap（默认）：不换行。\n- wrap：换行，第一行在上方。\n- wrap-reverse：换行，第一行在下方。\n\n### flex-flow\n\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n```css\n.box {\n\tflex-flow: <flex-direction> <flex-wrap>;\n}\n```\n\n### justify-content属性\n\njustify-content属性定义了项目在主轴上的对齐方式。\n\n```css\n.box {\n\tjustify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n- flex-start（默认值）：左对齐\n- flex-end：右对齐\n- center： 居中\n- space-between：两端对齐，项目之间的间隔都相等。\n- space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n### align-items属性\n\nalign-items属性定义项目在交叉轴上如何对齐。\n\n```css\n.box {\n\talign-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n- flex-start：交叉轴的起点对齐。\n- flex-end：交叉轴的终点对齐。\n- center：交叉轴的中点对齐。\n- baseline: 项目的第一行文字的基线对齐。\n- stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### align-content属性\n\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n```css\n.box {\n\talign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n该属性可能取6个值。\n\n- flex-start：与交叉轴的起点对齐。\n- flex-end：与交叉轴的终点对齐。\n- center：与交叉轴的中点对齐。\n- space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n- stretch（默认值）：轴线占满整个交叉轴。\n\n## 项目属性\n\n### order属性\n\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n```css\n.item {\n\torder: <integer>;\n}\n```\n\n### flex-grow属性\n\nflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\n```css\n.item {\n\tflex-grow: <number>; /* default 0 */\n}\n```\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### flex-shrink属性\n\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```css\n.item {\n\tflex-shrink: <number>; /* default 1 */\n}\n```\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### flex-basis属性\n\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n```css\n.item {\n\tflex-basis: <length> | auto; /* default auto */\n}\n```\n\n该样式属性与width样式属性的作用完全相同。\n\n### flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n```css\n.item {\n\tflex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### align-self属性\n\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n```css\n.item {\n\talign-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\n\n\n\n","tags":["CSS3"]},{"title":"JS严格模式","url":"/2019/04/12/JS严格模式/","content":"\n## 序言\n\n除了正常运行模式，ECMAscript 5添加了第二种运行模式：\"严格模式\"（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。\n\n<!-- more -->\n\n## 初衷\n\n- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行\n- 消除代码运行的一些不安全之处，保证代码运行的安全；\n- 提高编译器效率，增加运行速度；\n- 为未来新版本的Javascript做好铺垫。\n\n## 进入标志\n\n进入\"严格模式\"的标志，是下面这行语句:\n\n```js\n\"use strict\";\n```\n\n## 如何调用\n\n\"严格模式\"有两种调用方法，适用于不同的场合。\n\n### 针对整个脚本文件\n\n将\"use strict\"放在脚本文件的第一行，则整个脚本都将以\"严格模式\"运行。如果这行语句不在第一行，则无效，整个脚本以\"正常模式\"运行。\n\n```js\n<script>\n　　\"use strict\";\n\tconsole.log(\"这是严格模式。\");\n</script>\n```\n\n### 针对单个函数\n\n将\"use strict\"放在函数体的第一行，则整个函数以\"严格模式\"运行。\n\n```js\nfunction strict(){\n　　\"use strict\";\n\treturn \"这是严格模式。\";\n}\n```\n\n## ES6\n\nES6的模块自动采用严格模式，不管有没有在模块头部加上\"use strict\"。\n\n## 严格模式下的限制\n\n- 变量必须声明后再使用。\n- 函数的参数不能有同名属性，否则报错。\n- 不能使用with语句。\n- 不能对只读属性赋值，否则报错。\n- 不能使用前缀0表示八进制，否则报错。\n- 不能删除不可能删除的属性，否则报错。\n- 不能删除变量(delete prop)，会报错，只能删除属性(delete global[prop])。\n- eval不会在其外层作用域引入变量。\n- eval和arguments不能被重新赋值。\n- arguments不会自动反映函数参数的变化。\n- 不能使用arguments.callee。\n- 不能使用arguments.caller。\n- 禁止this指向全局对象。\n- 不能使用fn.caller和fn.arguments获取函数调用的堆栈。\n- 增加了保留字(比如protected、static和interface)。\n\n","tags":["JavaScript"]},{"title":"css布局相关","url":"/2019/04/04/css布局相关/","content":"\n## 序言\n\n学习前端，学习CSS还是有必要的，CSS在布局方面非常重要，而如果我们能熟悉掌握CSS，那么在布局的时候就能如鱼得水。\n<!--more-->\n\n## margin\n\n### margin与可视尺寸\n\n- 适用于没有设定width/height的普通block的水平元素(float元素 absolut/fixed元素 inline水平, table-cell)\n- 只适用于水平尺寸\n- 实现一侧定宽的自适应布局\n\n### margin与占据尺寸\n\n- block/inline-block水平元素均适用\n- 与有没有设定width/height值无关\n- 适用于水平方向和垂直方向\n- 实现滚动容器内上下留白(适用margin)\n\n### margin的百分比\n\n- 水平方向百分比/垂直方向百分比\n- 普通元素百分比/绝对定位元素的百分比\n- 普通元素的百分比margin都是相对于容器的宽度计算的\n- 绝对定位的元素的百分比margin是相对于第一个定位祖先元素(absolute/relative/fixed)的宽度计算的\n\n### margin重叠通常特性\n\n- block水平元素(不包括float和absolute元素)\n- 不考虑writing-mode, 只发生在垂直方向(margin-top/margin-bottom)\n\n### margin重叠的3种情境\n\n- 相邻的兄弟元素\n- 父级和第一个/最后一个子元素\n- 空的block元素\n\n### margin-top重叠\n\n- 父元素非块状格式化上下文\n- 父元素没有border-top设置\n- 父元素没有padding-top值\n- 父元素和第一个子元素之间没有inline元素分隔\n\n### margin-bottom重叠\n\n- 父元素非块状格式化上下文\n- 父元素没有border-top设置\n- 父元素没有padding-top值\n- 父元素和第一个子元素之间没有inline元素分隔\n- 父元素没有height, min-height, max-height限制\n\n### 空block元素margin重叠其他条件\n\n- 元素没有border设置\n- 元素没有padding值\n- 里面没有inline元素\n- 没有height, 或者min-height\n\n### 重叠取值\n\n- 正正取大值\n- 负负最负值\n- 正负值相加\n\n### 理解margin auto\n\n元素有时候, 就算没有设置width或height, 也会自动填充；原本应该填充的尺寸被width/height强制变更, 而margin: auto就是为了填充这个变更的尺寸设计的；如果一侧定值, 一侧auto, auto为剩余空间大小; 如果两侧军均是auto, 则平分剩余空间的；图片为何不居中呢？因为此图片是inline水平, 就算没有width,其也不会占据整个容器；\n\nabsolute与margin居中\n\n```css\n.father{height: 200px; position: relative}\n.son{position: absolute; top: 0px; right: 0px; bottom: 0px; left: 0px;}\n\n.father{height: 200px; position: relative}\n.son{position: absolute; top: 0px; right: 0px; bottom: 0px; left: 0px; margin: auto}\n```\n\n### margin”无效”\n\n- inline水平元素的垂直margin无效\n- margin重叠\n- position: absolute与margin(绝对定位元素的非定位方位值”无效”)\n- 绝对定位的margin值一直有效, 只是不像普通元素那样, 可以和兄弟元素插科打诨\n\n\n## position\n\n### absolute\n\n#### absolute特性\n\n- 包裹性\n- 破坏性\n- 去浮动\n- 位置跟随性\n- 超越overflow\n- 脱离文档流\n\n#### absolute的强大之处\n\n没有宽度和高度声明实现的全屏自适应效果\n\n```css\nposition: absolute; \nleft: 0; top: 0; right: 0; bottom: 0;//实现布满整个容器\n```\n\n### relative\n\n#### relative特性\n\n- 相对自身\n- 无浸入(不影响其他盒子模型的定位)(原本的位置还存在)\n\n#### relative的作用:限制absolute\n\n- 限制left/top/right/bottom定位\n- 限制z-index层级(可以对fixed的限制有效)\n- 限制在overflow下的嚣张气焰\n- 尽量少用relative\n\n## float\n\n### float的诞出的初始目的\n\n- 文字环绕效果\n\n### float的特性\n\n- 包裹性\n- 破坏性\n- 脱离文档流\n- float浮动去空格\n- 浮动与display:inline-block化(破坏性造成紧密排列)\n\n### 清除浮动(应该应用在其父级元素上)\n\n```css\n.clearfix:after{\n\tcontent:’’; \n\tdisplay: block; \n\theight:0; \n\tclear:both\n}\n```\n\n## line-height\n\n### line-height的定义\n\n- 行高, 两行文字基线之间的距离\n- 一行文字也是有行高的(两行的定义已经决定了一行的表现)\n\n### line-height与行内框盒子模型\n\n- 所有内联元素的样式表现都与行内框盒子模型有关!例如浮动的图文环绕效果\n- “内容区域”，是一种环绕文字看不见的盒子。 “内容区域”的大小与font-size大小相关\n- “内联盒子”，”内联盒子”不会让内容成块显示，而是排成一行。如果外部含inline水平标签(span, a, em等),则属于”内联盒子”。如果是个光秃秃的文字，则属于”匿名内联盒子”\n- “行框盒子”,每一行就是一个”行框盒子”，每个”行框盒子”又是由一个个”内联盒子组成”\n- p标签所在的”包含盒子”, 此盒子由一行行的”行框盒子”组成\n- 没有定高的盒模型并不是由文字撑开, 是由行高决定\n- 行高由于其继承性，影响无处不在，即使单行文本也比例外\n- 行高只是幕后黑手，高度的表现不是行高，而是内容区域和行间距\n- 内容区域高度 + 行间距 = 行高\n- 内容区域高度至于字号以及字体有关，与行高没有任何关系\n- 行高决定内联盒子高度；行间距墙头草，可大可小(甚至负值),保证高度正好等同于行高\n- 多行文本的高度就是单行文本高度累加\n- line-height: normal(默认属性值)\n- 行高不会影响图片的占据的高度\n- 隐匿的文本节点\n\n### 消除图片底部间隙的方法\n\n- 图片块状化-无基线对齐\n- 图片底线对齐img{vertical-align: bottom}\n- 行高足够小-基线位置上移.box{line-height: 0;}\n\n### line-height的实际应用\n\n大小不固定的图片,多行文字垂直居中\n\n```css\n.box{\n\tline-height: 300px; \n\ttext-align: center;\n}\n.box > img{\n\tvertical-align: middle;\n}\n```\n\n多行文本水平居中\n\n```css\n.box{\n\tline-height: 250px; \n\ttext-align: center;\n}\n.box > .text{\n\tdisplay: inline-block; \n\tline-height: normal; \n\ttext-align: left; \n\tvertical-align: middle;\n}\n```\n\n## padding\n\n### padding的特性\n\n- padding不支持任何形式的负值\n- padding百分比均是相对于宽度计算的\n\n### padding对于block水平元素的影响\n\n- padding值暴走，一定影响尺寸\n- width非auto, padding影响尺寸\n- width为auto或box-sizng为border-box, 同时padding值没有暴走，不影响尺寸\n\n### padding对inline水平元素的影响\n\n- 水平padding影响尺寸, 垂直padding不影响尺寸，但是会影响背景色(占据空间)\n- 可以用来实现高度可控的分隔符\n\n### inline水平元素的padding百分比值\n\n- 相对于宽度计算\n- padding会断行\n- 默认的高度宽度细节有差异\n- inline元素的垂直padding会让”幽灵空白节点”显现(造成padding宽高不等)\n\n## border\n\n### border的特性\n\n- border-width不支持百分比(类似的outline, text-shadow, border-shadow)\n- border-style特性(solid(实线), dashed(虚线), dotted(点线, double(双线)))\n- 不指定border-color时默认就是color(类似的text-shadow, border-shadow)\n\n## overflow\n\n### overflow的特性\n\n- 属性(visible, hidden, scroll, auto, inherit)\n- 如果overflow-y=overflow-x值相同, 则等同于overflow;\n- 如果overflow-y=overflow-x值不同, 且其中一个属性的值被置为visible, 而另一个被赋予hidden, - scroll, auto,那么这个visible被重置为auto;\n- 无论什么浏览器, 默认滚动条均默认来自html而不是body标签\n- 浏览器默认IE8+html(overflow: auto)\n- overflow的padding-bottom缺失(除chrome其他都缺失)\n- overflow与BFC(块状化格式上下文)——(清除浮动, 自适应布局等)\n\n### 触发BFC(overflow: auto, hidden, scroll)———(页面结界, 内部元素再怎么也不影响外部)\n\n- 应用(清除浮动影响, 避免margin穿透问题, 两栏自适应布局)\n- overflow对绝对定位元素失效(避免失效:verflow元素自身为包含块(relative), overflow子元素为包含块)\n- resize属性,resize:both(水平垂直),resize:horizontal(只有水平拉), resize:vertical(只有垂直拉),(此声明要想起作用,overflow属性值不能是visible)\n- overflow与锚链接\n\n## vertical-align\n\n### vertical-align的特性\n\n- 线类 baseline, top, middle, bottom\n- 文本类 text-top, text-bottom\n- 上标下标类 sub, super\n- 数值百分比类(在baseline对齐基础上上下偏移对应数值大小)\n- 20px,2em,20%(百分比是相对于Line-height计算的)\n- 应用于Inline水平以及”table-cell”元素\n\ninline水平\n\n- inline: img, span\n- inline-block: input, button\n\ntable-cell\n\n- table-cell: td(对自身起作用)\n- inline-block的基线是正常流中最后一个line box的基线，除非这个line box里面既没有Line boxes或者本身overflow属性的计算值而不是visible, 这种情况下基线是margin底边缘\n\n### 线性类属性值\n\nbottom\n\n- inline/inline-block元素： 元素底部和整行的底部对齐\n- table-cell元素: 单元格底padding边缘和表格行的底部对齐\n\ntop\n\n- inline/inline-block元素： 元素顶部和整行的顶部对齐\n- table-cell元素: 单元顶部padding边缘和表格行的顶部对齐\n\nmiddle\n\n- inline/inline-block元素： 元素的垂直中心点和父元素的基线上1/2x_height处对齐对齐\n- table-cell元素: 单元格填充盒子相对于外面的表格行居中对齐\n\n文本类属性\n\n- vertical-align: text-top;(盒子的顶部和父级content area的顶部对齐)\n- vertical-align: text-top;(盒子的底部和父级content area的底部对齐)\n\n上标, 下标\n\n- <sup> => vertical-align: sup;\n- <sub> => vertical-align: sub;\n- vertical-align: sup(提高盒子的基线到父级合适的上标基线位置)\n- vertical-align: sub(降低盒子的基线到父级合适的下标基线位置)\n\n## CSS3\n\n\n## BFC(块格式化上下文)\n\n块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\n下列方式会创建块格式化上下文：\n\n- 根元素或包含根元素的元素\n- 浮动元素（元素的 float 不是 none）\n- 绝对定位元素（元素的 position 为 absolute 或 fixed）\n- 行内块元素（元素的 display 为 inline-block）\n- 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）\n- 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）\n- 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）\n- overflow 值不为 visible 的块元素\n- display 值为 flow-root 的元素\n- contain 值为 layout、content或 strict 的元素\n- 弹性元素（display为 flex 或 inline-flex元素的直接子元素）\n- 网格元素（display为 grid 或 inline-grid 元素的直接子元素）\n- 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）\n- column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中\n\n块格式化上下文包含创建它的元素内部的所有内容.\n\n块格式化上下文对浮动定位（参见 float）与清除浮动（参见 clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。\n","tags":["CSS"]},{"title":"浅谈浏览器缓存机制","url":"/2019/03/17/浅谈浏览器缓存机制/","content":"\n## 序言\n\n缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。\n\n<!-- more -->\n\n## 缓存\n\n通常浏览器缓存策略分为两种：强缓存和协商缓存。\n\n几条关于缓存的规则：\n\n- 添加Expires或Cache-Control到报文头中\n- 配置ETags\n- 让Ajax可缓存\n\n通常来说，POST、DELETE、PUT这类行为性的请求操作一般不做任何缓存，大多数缓存只应用在GET请求中。\n\n### 强缓存\n\n### 协商缓存"},{"title":"Script标签","url":"/2019/03/15/Script标签/","content":"\n## 序言\n\n向HTML页面中插入JavaScript的主要方法，就是使用script元素。\n\n<!-- more -->\n\n## 使用\n\n### 属性\n\n- async：可选，表示应该立即下载脚本，但不应该妨碍页面中的其他操作。只对外部脚本文件有效。\n- charset：可选，表示通过src属性指定的代码的字符集，大多数浏览器会忽略它，一般不被人使用。\n- defer：可选，表示脚本可以延迟到文档完全解析和显示之后再执行。只对外部脚本文件有效。\n- src：可选，表示包含要执行代码的外部文件。\n- type：可选，表示编写代码使用的脚本语言的内容类型。\n\n\n### 标签位置\n\n#### header元素中\n\nheader元素中包含所有的JavaScript文件，意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后，才能开始呈现页面的内容(浏览器在遇到body标签时才开始呈现内容)。对于那些需要很多JavaScript代码的页面来说，这无疑会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器窗口中将是一片空白。\n\n一般避免的办法是把全部JavaScript引用放到在body元素内容的后面，这样子，在解析包含的JavaScript代码之前，页面的内容将完全呈现在浏览器中。\n\n### 延迟脚本(defer属性)\n\ndefer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都被解析完毕后再运行。因此，在script元素中设置defer属性，相当于告诉浏览器立即下载，延迟执行。\n\nHTML5规范要求脚本按照他们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定在DOMContentLoaded事件触发前执行，因此最好只包含一个延迟脚本。\n\n### 异步脚本(async属性)\n\nasync这个属性与defer属性类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。\n\n使用async属性，如果引入两个脚本文件，第二个脚本文件可能会在第一个脚本文件之前执行。因此，确保两者之间互不依赖非常重要。指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。\n\n异步脚本一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。\n\n"},{"title":"浅谈JavaScript的闭包","url":"/2019/03/08/浅谈JavaScript的闭包/","content":"\n## 序言\n\n在JS中闭包是一个很重要的概念，很多地方都运用到了闭包，所以有必要深入理解一下闭包。\n\n<!-- more -->\n\n## 基本概念\n\n闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。\n\n```js\nfunction createCompareFn (propertyName) {\n\treturn function (object1, object2) {\n\t\tvar value1 = object1[propertyName];\n\t\tvar value2 = object2[propertyName];\n\t\t\n\t\tif (value1 < value2) {\n\t\t\treturn -1;\n\t\t} else if (value1 > value2) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n```\n\n内部函数访问了外部函数的变量propertyName，之所以还能够访问这个变量，是因为内部函数的作用域链中包含外部函数的作用域链。","tags":["JavaScript"]},{"title":"JavaScript的变量声明","url":"/2019/03/07/JavaScript的变量声明/","content":"\n## 序言\n\n在ES6出世以前，在JavaScript中声明变量的方式只有var，在ES6出世以后，新增了let、const两种变量声明的方式。\n\n<!-- more -->\n\n## ES5的var声明\n\n### 基本用法\n\nECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。\n\n```js\nvar message\n```\n\n这行代码定义了一个名为message的变量，该变量可以用来保存任何值（像这样未经过初始化的变量，会保存一个特殊的值--undefined）\n\n直接初始化变量，在定义的同时直接给予赋值\n\n```js\nvar message = 'hi'\n```\n\n用var操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁，例如:\n\n```js\nfunction test () {\n\tvar message = 'hi';\t\t//局部变量\n}\ntest();\nconsole.log(message);\t\t//错误\n```\n\n给一个未定义声明过的变量赋值时，会创建一个全局变量：\n\n```js\nfunction test () {\n\tmessage = \"hi\";\t\t// 全局变量\n}\ntest();\nconsole.log(message);\t// 'hi'\n```\n给未经声明的变量赋值在严格模式下会导致抛出ReferenceError错误\n\n### 重复声明\n\nJavaScript从来不会告诉你是否多次声明了同一变量；遇到这种情况，它只会对后续的声明视而不见(不过，它会执行后续声明中的变量初始化，如果声明不初始化如果值不变)。\n\n```js\nvar i = 10;\nconsole.log(i);\t//10\nvar i;\nconsole.log(i);\t//10\n```\n\n### 变量提升\n\nvar声明变量存在变量提升\n\n```js\nconsole.log(foo);\t//undefined\nvar foo = 2;\n```\n\n### 全局对象的属性\n\n所有在全局作用域中声明的变量、函数都会变成global(浏览器环境中是window)对象的属性和方法。\n\n```js\nvar age = 20;\nfunction sayAge () {\n\tconsole.log(this.age);\n}\n\nconsole.log(global.age);\t//29\nsayAge();\t\t\t\t\t\t//29\nwindow.sayAge();\t\t\t\t//29\n\n```\n\n全局变量不能通过delete操作符删除，而直接在global对象上的定义的属性可以。\n\n```js\nvar age = 20;\nglobal.color = 'red';\n\ndelete global.age;\t\t\t\t\t//return false\n\ndelete global.color;\t\t\t\t//return true\n\nconsole.log(global.age);\t\t\t//20\nconsole.log(global.color);\t\t\t//undefined\n\n```\n\n尝试访问未声明的变量会抛出错误，但是通过查询global对象，可以知道某个可能未声明的变量是否存在。例如：\n\n```js\nvar newValue = oldValue;\t\t\t\t//这里会抛出错误，因为oldValue未定义\n\nvar newValue = window.oldValue;\t\t//这里不会抛出错误，因为这是一次属性查询\n\n```\n\n## ES6的let、const声明\n\n### let\n\n#### 基本用法\n\nlet声明的变量只在let命令所在的代码块内有效\n\n```js\n{\n\tlet a = 10;\n\tvar b = 1;\n}\n\na\t// ReferenceError: a is not defined\nb\t//1\n```\n\nfor循坏的计数器，就很适合使用let命令。\n\n```js\nfor(let i = 0; i < arr.length; i++) {};\n\nconsole.log(i);\n//ReferenceError\n```\n以上代码中的计数器i，只在for循环体内有效。\n\n一下的代码如果使用var，最后将输出10。\n\n```js\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n\ta[i] = function () {\n\t\tconsole.log(i);\n\t}\n}\na[6]();\t//10\n```\n\n上面的代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i值。\n\n#### 暂时性死区\n\n只要块级作用域内存在let命令，它所声明的变量就“绑定”(binding)这个区域，不再受外部的影响。\n\n```js\nvar tmp = 123;\n\nif (true) {\n\ttmp = 'abc';\t//ReferenceError\n\tlet tmp;\n}\n```\n上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\n\nES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。\n\n#### 不允许重复声明\n\nlet 不允许在相同作用域内声明同一个变量。\n\n```js\n//报错\nfunction () {\n\tlet a = 10;\n\tvar a = 1;\n}\n\n//报错\nfunction () {\n\tlet a = 10;\n\tlet a = 1;\n}\n```\n\n不能在函数内部重新声明参数。\n\n```js\nfunction func(arg) {\n\tlet arg;\t//报错\n}\n\nfunction func (arg) {\n\t{\n\t\tlet arg;\t//不报错\n\t\n\t}\n}\n```\n\n### const\n\n#### 基本用法\n\nconst用来声明常量。一旦声明，其值就不能改变。\n\n```js\nconst PI = 3.1415; \nPI \t\t\t//3.1415\n\nPI = 3 \t//\tTypeError: \"PI\" is\tread-only\n```\n\nconst声明的常量不得改变值。这意味着，const一旦声明常量，就必须立即初始化，不能留到以后赋值。\n\n#### 全局对象的属性\n\n全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js中指的是global对象。在ES5中，全局对象的属性和全局变量是等价的。\n\n```js\nwindow.a = 1;\na //1\n\na = 2;\nwindow.a //2\n```\n\n这种规定被视为JavaScript语言的一大问题，因为很容易不知不觉就创建了全局变量。ES6位了改变这一点，一方面规定，var命令和function命令声明的全局变量依旧是全局对象的属性；另一方面规定，let命令、const命令和class命令声明的全局变量不属于全部对象的属性。\n\n```js\nvar a = 1;\nwindow.a //1\n\nlet b = 1;\nwindow.b //undefined\n```\n\n\n","tags":["JavaScript"]},{"title":"写一个Promise","url":"/2019/03/05/写一个Promise/","content":"\n## 序言\n\nJS和Node.js通过事件驱动、事件循环实现了异步编程，提高了资源利用率，提高了性能，但也因此带来了异步编程的难点。为了解决异步编程带来的难点，社区出了好几个解决方案，事件发布/订阅模式、Promise/Deferred模式、流程控制库，最终Promise成为了ES6中一个解决异步编程难点的API，再配合ES2017中Async/Await真正解决异步编程的难点。\n\n<!-- more -->\n\n## 介绍Promise\n\n### Promise的含义\n\n所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。\n\nPromise有两个特点:\n\n1. 对象的状态不受外界影响。Promise对象代表一个异步操作，有3种状态：Pending(进行中)，Resolved(已完成，又称Fuilfilled)和Rejected(已失败)。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n2. 一旦状态改变就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变只有两种可能，从Pending变为Resolved和从Pending变为Rejected。只要其中之一发生，状态就凝固了，不会再变，会一直保持这个结果。\n\n### Promise基本用法\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例。\n\n```js\nconst promise = new Promise(function () {\n\t// ... some code\n\t\n\tif (/* 异步操作成功 */) {\n\t\tresolve(value);\n\t} else {\n\t\treject(error);\n\t}\n});\npromise.then(function (value) {\n\t//success\n}, function (value) {\n\t//failure\n});\n```\n\n## 实现Promise\n\n### 基于事件发布/订阅实现\n\n```js\nconst EventEmitter = require('events');\nclass Promise extends EventEmitter {\n\tconstructor (handler) {\n\t\tsuper();\n\t\tthis.state = 'pendding';\n\t\tthis.resolve = this.resolve.bind(this);\n\t\tthis.reject = this.reject.bind(this)\n\t\tif (typeof handler == 'function') {\n\t\t\thandler(this.resolve, this.reject);\n\t\t}\n\t}\n\n\tresolve (obj) {\n\t\tif (this.state == 'pendding') {\n\t\t\tthis.state = 'resolved';\n\t\t\tthis.emit('resolved', obj);\n\t\t}\n\t}\n\n\treject (err) {\n\t\tif (this.state == 'pendding') {\n\t\t\tthis.state = 'rejected';\n\t\t\tthis.emit('rejected', err);\n\t\t}\n\t}\n\n\tthen (resolvedHandler, rejectedHandler) {\n\t\tif (typeof resolvedHandler == 'function') {\n\t\t\tthis.once('resolved', resolvedHandler);\n\t\t}\n\n\t\tif (typeof rejectedHandler == 'function') {\n\t\t\tthis.once('rejected', rejectedHandler);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcatch (rejectedHandler) {\n\t\tif (typeof rejectedHandler == 'function') {\n\t\t\tthis.once('rejected', rejectedHandler);\n\t\t}\n\t}\n}\n```\n\n### 实现链式调用\n\n```js\n// 三种状态\nconst PENDING = \"pending\";\nconst RESOLVED = \"resolved\";\nconst REJECTED = \"rejected\";\n// promise 接收一个函数参数，该函数会立即执行\nfunction MyPromise(fn) {\n  let _this = this;\n  _this.currentState = PENDING;\n  _this.value = undefined;\n  // 用于保存 then 中的回调，只有当 promise\n  // 状态为 pending 时才会缓存，并且每个实例至多缓存一个\n  _this.resolvedCallbacks = [];\n  _this.rejectedCallbacks = [];\n\n  _this.resolve = function (value) {\n    if (value instanceof MyPromise) {\n      // 如果 value 是个 Promise，递归执行\n      return value.then(_this.resolve, _this.reject)\n    }\n    setTimeout(() => { // 异步执行，保证执行顺序\n      if (_this.currentState === PENDING) {\n        _this.currentState = RESOLVED;\n        _this.value = value;\n        _this.resolvedCallbacks.forEach(cb => cb());\n      }\n    })\n  };\n\n  _this.reject = function (reason) {\n    setTimeout(() => { // 异步执行，保证执行顺序\n      if (_this.currentState === PENDING) {\n        _this.currentState = REJECTED;\n        _this.value = reason;\n        _this.rejectedCallbacks.forEach(cb => cb());\n      }\n    })\n  }\n  // 用于解决以下问题\n  // new Promise(() => throw Error('error))\n  try {\n    fn(_this.resolve, _this.reject);\n  } catch (e) {\n    _this.reject(e);\n  }\n}\n\nMyPromise.prototype.then = function (onResolved, onRejected) {\n  var self = this;\n  // 规范 2.2.7，then 必须返回一个新的 promise\n  var promise2;\n  // 规范 2.2.onResolved 和 onRejected 都为可选参数\n  // 如果类型不是函数需要忽略，同时也实现了透传\n  // Promise.resolve(4).then().then((value) => console.log(value))\n  onResolved = typeof onResolved === 'function' ? onResolved : v => v;\n  onRejected = typeof onRejected === 'function' ? onRejected : r => throw r;\n\n  if (self.currentState === RESOLVED) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行\n      // 所以用了 setTimeout 包裹下\n      setTimeout(function () {\n        try {\n          var x = onResolved(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (reason) {\n          reject(reason);\n        }\n      });\n    }));\n  }\n\n  if (self.currentState === REJECTED) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      setTimeout(function () {\n        // 异步执行onRejected\n        try {\n          var x = onRejected(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (reason) {\n          reject(reason);\n        }\n      });\n    }));\n  }\n\n  if (self.currentState === PENDING) {\n    return (promise2 = new MyPromise(function (resolve, reject) {\n      self.resolvedCallbacks.push(function () {\n        // 考虑到可能会有报错，所以使用 try/catch 包裹\n        try {\n          var x = onResolved(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (r) {\n          reject(r);\n        }\n      });\n\n      self.rejectedCallbacks.push(function () {\n        try {\n          var x = onRejected(self.value);\n          resolutionProcedure(promise2, x, resolve, reject);\n        } catch (r) {\n          reject(r);\n        }\n      });\n    }));\n  }\n};\n// 规范 2.3\nfunction resolutionProcedure(promise2, x, resolve, reject) {\n  // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用\n  if (promise2 === x) {\n    return reject(new TypeError(\"Error\"));\n  }\n  // 规范 2.3.2\n  // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行\n  if (x instanceof MyPromise) {\n    if (x.currentState === PENDING) {\n      x.then(function (value) {\n        // 再次调用该函数是为了确认 x resolve 的\n        // 参数是什么类型，如果是基本类型就再次 resolve\n        // 把值传给下个 then\n        resolutionProcedure(promise2, value, resolve, reject);\n      }, reject);\n    } else {\n      x.then(resolve, reject);\n    }\n    return;\n  }\n  // 规范 2.3.3.3.3\n  // reject 或者 resolve 其中一个执行过得话，忽略其他的\n  let called = false;\n  // 规范 2.3.3，判断 x 是否为对象或者函数\n  if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) {\n    // 规范 2.3.3.2，如果不能取出 then，就 reject\n    try {\n      // 规范 2.3.3.1\n      let then = x.then;\n      // 如果 then 是函数，调用 x.then\n      if (typeof then === \"function\") {\n        // 规范 2.3.3.3\n        then.call(\n          x,\n          y => {\n            if (called) return;\n            called = true;\n            // 规范 2.3.3.3.1\n            resolutionProcedure(promise2, y, resolve, reject);\n          },\n          e => {\n            if (called) return;\n            called = true;\n            reject(e);\n          }\n        );\n      } else {\n        // 规范 2.3.3.4\n        resolve(x);\n      }\n    } catch (e) {\n      if (called) return;\n      called = true;\n      reject(e);\n    }\n  } else {\n    // 规范 2.3.4，x 为基本类型\n    resolve(x);\n  }\n}\n```","tags":["JavaScript"]},{"title":"HTML5 通讯API","url":"/2019/03/04/HTML5-通讯API/","content":"\n## 序言\n\nHTML5之前，前后端之间的数据交互比较单一，只能通过ajax技术实现两端之间的数据交互，而且只能由客户端向服务器端发送请求进而携带着数据发往服务器端，然后等待服务器端响应，响应中携带着客户端需要的服务器端数据，而服务器端无法主动向客户端主动发送数据。HTML5现世后，涌现出了两个新的API, WebSocket、SSE，实现了服务器端主动向客户端发往数据。\n \n<!-- more -->\n\n## WebSocket\n\n### 客户端实现方式\n\n```js\nconst webSocket = new WebSocket(\"ws://localhost:8080\"); //与服务器建立连接\n//url必须以\"ws\"或\"wss\"开头(加密通讯时)文字开头\n\nwebSocket.send(data);//向服务器发送数据\n//data可以是JSON对象转换为文本数据, 或着blob对象或arraybuffer对像\n\nwebSocket.onmassage = function (e) {\n    let massage = e.data;\n};//监听服务器端发来的数据\n\nwebsocket.onopen = function () {\n\n};//监听open事件，进而判断是否连接成功\n\nwebSocket.onclose = function () {\n\n};//监听close事件，进而判断连接是否关闭\n\nwebSocket.close();切断连接\n\nwebsocket.binaryType = arraybuffer || blob;//设置接受数据类型\n\n```\n\n\n### 服务器端实现方式\n\n使用Node.js的ws、 socket.io模块来实现\n\n#### WS实现\n\n```js\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ port: 8080 });\n\n// Broadcast to all.(向所有连接的socket发送数据)\nwss.broadcast = (data) => {\n     wss.clients.forEach((client) => {\n        if (client.readyState === WebSocket.OPEN) {\n              client.send(data);\n           }\n      });\n};\n\nwss.on('connection', (ws) => {\n    ws.on('message', (data) => {\n        // Broadcast to everyone else.(像其他人广播数据)\n        wss.clients.forEach((client) => {\n            if (client !== ws && client.readyState === WebSocket.OPEN) {\n                client.send(data);\n            }\n        });\n    });\n});\n\n```\n\n结合Express一起使用\n\n```js\nconst express = require('express');\nconst http = require('http');\nconst url = require('url');\nconst WebSocket = require('ws');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\napp.use((req, res) => {\n  res.send({ msg: \"hello\" });\n});\n\nwss.on('connection', (ws) => {\n  const location = url.parse(ws.upgradeReq.url, true);\n  // You might use location.query.access_token to authenticate or share sessions\n  // or ws.upgradeReq.headers.cookie\n  ws.on('message', (message) => {\n    console.log('received: %s', message);\n  });\n  ws.send('something');\n});\n\nserver.listen(8080, () => {\n  console.log('Listening on %d', server.address().port);\n});\n```\n\n#### SOCKET.IO实现方式\n\n```js\n//服务端建立socket\nconst io = require(\"socket.io\");//服务器引入socket.io\nconst socket = io.listen(server);//server为一个http服务器\n\n//客户端建立socket\n<script src=\"/socket.io/socket.io.js\"></script>//客户端引入socket.io\nconst socket = io();\n\n//公共API\nsocket.on('connection', callback);//监听连接事件\n\nsocket.on('disconnection', callback);//监听断开连接事件\n\nsocket.on(\"message\", callback);//监听接受消息事件\n\nsocket.send();//向对端发送数据\n\nsocket.emit(event, data, [callback])；//发布事件，callback由对方进行调用及形参的传进\n\nsocket.on(event, function (data, fn) {});//事件监听\n\nsocket.once();//监听事件，只触发一次\n\n保存数据:\nsocket.set(name, value, [callback]);\nsocket.get(name, callback)\n//callback: (err, docs) => {};\n\n广播消息:\nio.sockets.\nsocket.broadcast.\n\n使用命名空间:\nio.of(namespace)\nconst chat = io.of(\"/chat\");\nchat.on(\"connection\", callback);//监听连接\n\nconst chat = io.connect(\"http://localhost/chat\");//建立连接\n```\n\n## SSE\n\n是一种从服务器端发往客户端的单向通信机制，由服务器端发送一些事件, 再由客户端接收这些事件\n\n### 客户端实现方式\n\n```js\nconst source = new EventSource(url);\nsource.onmessage = (e) => {e.data};\nsource.onopen = () => {};\nsource.onerror = (e) => {};\nsource.close();\n```\n\n### 服务器端实现方式\n\n服务器端发送的数据只能以一个字符串的形式发送，对象必须转为JSON字符串进行发送\n\n```js\nres.writeHeader(200, {\"Content-Type\": \"text/event-stream\"}, \"Cache-Control\": \"no-cache\"); //必须指定浏览器不缓存服务器发送的数据\n```\n\n发送事件\n\n```\necho \"id: requests \\n\\n\"\necho \"data: 数据 \\n\\n\"\necho \"retry: 5000\\n\\n\"\n```\n\n//每行数据之前必须书写\"data: \"前缀，同时在行结尾需书写\"\\n\\n\"换行标志\n//指定客户端每隔多长时间与服务器建立一次连接并获取事件流，不指定由浏览器决定\n\n\n","tags":["Web通讯"]},{"title":"ECMAScript 面向对象","url":"/2019/03/04/ECMAScript-面向对象/","content":"\n## 序言\n\n很多编程语言都有面向对象的编程，ECMAScript同样也是如此。ECMAScript语言的传统方法是通过构造函数定义并生成新对象，自从ES6出来之后，ES6提供了更接近传统语言的写法，引入了Class(类)这个概念作为对象的模板。\n\n<!-- more -->\n\n## ES5的面相对象\n\n### 理解对象\n\n#### 属性类型\n\nECMAScript中有两种属性：数据属性和访问器属性。\n\n##### 数据属性\n\n数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。\n\n- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。对象字面量定义这个特性默认值为true\n- [[Enumerable]]：表示能否通过for-in循环返回属性。对象字面量定义这个特性默认值为true\n- [[Writable]]：表示能否修改属性的值。对象字面量定义这个特性默认值为true\n- [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把这个新值保存在这个位置。这个特性的默认值为undefined\n\n对于对象字面量，[[Configurable]]、[[Enumerable]]、[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值。例如：\n\n```js\nvar person = {\n\tname: \"sceley\"\n}\n```\n\n要修改属性默认的特性，必须使用ES5的Object.defineProperty()方法。这个方法接收三参数：属性所在的对象、属性的名字和一个描述符对象。其中描述符对象的属性必须是：[[Configurable]]、[[Enumerable]]、[[Writable]]、[[Value]]。设置其中的一个或多个值，可以修改对象的特性值。\n\n##### 访问器属性\n\n访问器属性不包含数据值；它们包含一对儿getter和setter函数(不过，这两个函数都不是必需的)。要读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理函数。访问器属性有如下4个属性。\n\n- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。对象字面量定义这个特性默认值为true\n- [[Enumerable]]：表示能否通过for-in循环返回属性。对象字面量定义这个特性默认值为true\n- [[Getter]]：在读取属性时调用的函数。默认值为undefined。\n- [[setter]]：在写入属性时调用的函数。默认值为undefined。\n\n访问器不能直接定义，必须使用Object.defineProperty()来定义。\n\n```js\nvar book = {\n\t__year: 2004,\n\tedition: 1\n}\nObject.defineProperty(book, 'year', {\n\tget: function () {\n\t\treturn this._year;\n\t},\n\tset: function (value) {\n\t\tthis._year = value;\n\t}\n});\n```\n\n### 创建对象\n\n#### 工厂模式\n\n工厂模式是软件工程领域一种广为人知的设计模式，用函数来封装以特定接口创建对象的细节。\n\n```js\nfunction createPerson (name, age, job) {\n\tvar o = new Object();\n\to.name = name;\n\to.age = age;\n\to.job = job;\n\to.sayName = function () {\n\t\tconsole.log(this.name);\n\t};\n\treturn o;\n}\n```\n\n缺点：工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题。\n\n#### 构造函数模式\n\nES中的构造函数可以用来创建指定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。\n\n```js\nfunction Person (name, age, job) {\n\tthis.name = name;\n\tthis.age = age;\n\tthis.job = job;\n\tthis.sayName = function () {\n\t\tconsole.log(this.name);\n\t}\n}\nvar person1 = new Person('sceley', 20, \"Engineer\");\nvar person2 = new Person('kitty', 20, \"Doctor\");\n```\n\n以这种方式调用构造函数实际上会经历以下4个步骤：\n\n1. 创建一个新对象\n2. 将构造函数的作用域赋给新对象(因此this就指向了这个新对象)\n3. 执行构造函数中的代码（为这个新对象添加属性）\n4. 返回对象\n\n构造函数的缺点就是每个方法都要在每个实例上重新创建一遍。\n\n#### 原型模式\n\n我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。\n\n```js\nfunction Person () {\n}\nPerson.prototype.name = \"sceley\";\nPerson.prototype.name = 22;\nPerson.prototype.sayName = function () {\n\tconsole.log(this.name);\n}\n```\n\n#### 组合使用构造函数模式和原型模式\n\n```js\nfunction Person(name, age, job) {\n\tthis.name = name;\n\tthis.age = age;\n\tthis.job = job;\n\tthis.friends = ['sceley', 'kitty'];\n}\nPerson.prototype = {\n\tconstructor: Person,\n\tsayName: function () {\n\t\tconsole.log(this.name);\n\t}\n};\n```\n\n这种构造函数与原型混成的模式，是目前认同度高的一种创建自定义类型的方法。\n\n### 继承\n\n#### 组合继承\n\n```js\nfunction Biology (name, age, category) {\n    this.age = age;\n    this.name = name;\n    this.category = category;\n}\n\nBiology.prototype.sayCategory = function () {\n    return this.category;\n}\n\nBiology.prototype.sayName = function () {\n    return this.name;\n}\n\nBiology.prototype.sayAge = function () {\n    return this.age;\n}\n\nfunction Animal (name, age, feed) {\n    this.feed = feed;\n    Biology.call(this, name, age, 'animal');\n}\n\nAnimal.prototype = new Biology();\nAnimal.prototype.constructor = Animal;\nAnimal.prototype.doFeed = function () {\n    if (this.feed >= 5) {\n        this.feed = this.feed - 5;\n        return `喂食成功, 饲料剩余${this.feed}斤`;\n    } else {\n        return '喂食失败, 饲料不足';\n    }\n}\n\nfunction Plant (name, age, water) {\n    this.water = water;\n    Biology.call(this, name, age, 'plant');\n}\n\nPlant.prototype = new Biology();\nPlant.prototype.constructor = Plant;\nPlant.prototype.doWater = function () {\n    if (this.water >= 10) {\n        this.water = this.water - 10;\n        return `浇水成功, 水剩余${this.water}桶`;\n    } else {\n        return '浇水失败, 水不足';\n    }\n}\n```\n\n缺陷：组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。\n\ntips:\n> 使用原型模式来让所有对象实例共享它所包含的属性和方法。\n\n> ES5中实现子类继承父类是使用了原型链作为主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。\n\n> 所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。\n\n> 通过原型来实现继承时，原型实际上会变成另一个类型的实例，解决的方法是借用构造函数技术，即在子类构造函数的内部调用超类型构造函数。\n\n> 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。\n\n> 组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例继承属性。\n\n\n#### 寄生组合继承\n\n所谓的寄生组合继承，即通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。其背后的基本思想是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。\n\n```js\nfunction inheritPrototype(subType, superType) {\n\tvar prototype = Object(superType.prototype);\n\tprototype.constructor = subType;\n\tsubType.prototype = prototype;\n}\n\nfunction SuperType(name) {\n\tthis.name = name;\n\tthis.colors = [\"red\", \"blue\", \"green\"];\n}\n\nSuperType.prototype.sayName = function () {\n\treturn this.name;\n}\n\nfunction SubType(name, age) {\n\tSuperType.call(this, name);\n\t\n\tthis.age = age;\n}\n\ninheritPrototype(SubType, SuperType);\n\nSubType.prototy.sayAge = function () {\n\treturn this.age;\n}\n```\n\n开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。\n\n\n## ES6类的面向对象\n\n```js\nclass Biology {\n\tconstructor (name, age, category) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.category = category;\n\t}\n\n\tsayName () {\n\t\treturn this.name;\n\t}\n\n\tsayAge () {\n\t\treturn this.age;\n\t}\n\n\tsayCategory () {\n\t\treturn this.category;\n\t}\n};\n\nclass Plant extends Biology {\n\tconstructor (name, age, water) {\n\t\tsuper(name, age, 'tree');\n\t\tthis.water = water;\n\t}\n\n\tdoWater () {\n\t    if (this.water >= 10) {\n\t        this.water = this.water - 10;\n\t        return `浇水成功, 水剩余${this.water}桶`;\n\t    } else {\n\t        return '浇水失败, 水不足';\n\t    }\n\t}\t\n};\n\nclass Animal extends Biology {\n\tconstructor (name, age, feed) {\n\t\tsuper(name, age, 'animal');\n\t\tthis.feed = feed;\n\t}\n\n\tdoFeed () {\n\t    if (this.feed >= 5) {\n\t        this.feed = this.feed - 5;\n\t        return `喂食成功, 饲料剩余${this.feed}斤`;\n\t    } else {\n\t        return '喂食失败, 饲料不足';\n\t    }\n\t}\n}\n```","tags":["JavaScript"]},{"title":"C语言中的多进程","url":"/2018/06/04/C语言中的多进程/","content":"\n## 序言\n\n为了充分利用计算机中的多核CPU，计算机提供了两个接口使用多核CPU，两个接口分别是：多进程、多线程。本编文章将介绍多进程编程，利用多核CPU。\n\n<!-- more -->\n\n## 多进程\n\n> 核的个数与可同时运行的进程数相同。相反，若进程数超过核数，进程将分时使用CPU资源。但因为CPU运行速度极快，我们会感到所有进程同时运行。当然多核越多，这种感觉也明显。\n\n### fork函数创建多进程\n\n```c\n#include <unistd.h>\n\npid_t fork(void);\n```\nfork函数将创建调用的进程副本。两个进程都将执行fork调用后的语句，子进程将复制父进程相同的内存空间，之后的程序流要根据fork函数的返回值加以区分。\n\n- 父进程：fork函数返回子进程ID\n- 子进程：fork函数返回0\n\n![](/img/fork函数创建进程.png)\n\neg.\n\n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint gval = 10;\nint main () {\n\tpid_t pid;\n\tint lval = 20;\n\tgval++, lval += 5;\n\t\n\tpid = fork();\n\tif (pid == 0) {//child pro\n\t\tgval += 2, lval += 2;\n\t} else {//parent pro\n\t\tgval -= 2, lval -= 2;\n\t}\n\t\n\tif (pid == 0) {\n\t\tprintf(\"Child Proc: [%d, %d] \\n\", gval, lval);\n\t} else {\n\t\tprintf(\"Parent Proc: [%d, %d] \\n\", gval, lval);\n\t}\n}\n```\n运行结果：\n\n![](/img/fork.png)\n\n### 进程与僵尸进程\n\n#### 僵尸进程的产生\n\n文件操作中，关闭文件和打开文件同等重要。同样进程的创建和进程的销毁同等重要。如果未认真对待进程销毁，它们将变成僵尸进程困扰各位。\n\n进程完成工作后（执行完main函数中的程序后）应当销毁，但有时这些进程将变成僵尸进程，占用系统中的重要资源。\n\n子进程的终止方式：\n\n- 传递参数并调用exit函数\n- main函数中执行return语句并返回值\n\n向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统。而操作系统并不会销毁子进程，直到把这些值传递给产生该子进程的父进程。\n\neg.\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main () {\n\tpid_t pid = fork();\n\tif (pid == 0) { Child Pro\n\t\tprintf(\"Hi, I am a child process \\n\");\n\t} else {\n\t\tprintf(\"Child Process ID: %d \\n\", pid);\n\t}\n\t\n\tif (pid) {\n\t\tputs(\"End child process \\n\");\n\t} else {\n\t\tprintf(\"End parent process \\n\");\n\t}\n}\n```\n\n#### 销毁僵尸进程\n\n为了销毁子进程，父进程应主动请求获取子进程的返回值。\n\n##### 使用wait函数\n\n```c\n#include <sys/wait.h>\n\npid wait(int * statloc);\n//成功时返回终止的子进程的ID，失败时返回-1\n```\n调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit函数的参数值、main函数的return返回值）将保存到该函数的参数所指内存空间。\n\n- WIFEXITED子进程正常终止时返回”真“ true\n- WEXITSTATUS返回子进程的返回值\n\neg.\n\n```c\n#include <stdio.h>\n#in\n#include <unistd.h>\n\nint main () {\n\tint status;\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t\treturn 3;\n\t} else {\n\t\tprintf(\"Child PID:%d \\n\", pid);\n\t\tpid = fork();\n\t\tif (pid == 0) {\n\t\t\texit(7);\n\t\t} else {\n\t\t\twait(&status);\n\t\t\tif (WIFEXITED(status)) {\n\t\t\t\tprintf(\"Child send one: %d \\n\", WEXITSTATUS(status));\n\t\t\t}\n\t\t\twait(&status)\n\t\t\tif (WIFEXITED(status)) {\n\t\t\t\tprintf(\"Child send tow: %d \\n\", WEXITSTATUS(status));\n\t\t\t}\n\t\t\tsleep(30);\n\t\t}\n\t}\n}\n```\n\n运行结果：\n\n![](/img/wait.png)\n\n调用wait函数时，如果没有已终止的子进程，那么程序将阻塞（Blocking）直到有子进程终止。\n\n##### 使用waitpid函数\n\nwait函数会引起程序阻塞，而waitpid即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出。\n\n```c\n#include <sys/wait.h>\n\npid_t waitpid(pid_t pid, int * statloc, int options);\n\n//成功时返回终止的子进程ID(或0)，失败时返回-1\n\n//1. pid 等待终止的目标子进程的ID， 若传递-1，则与wait函数相同，可以等待任意子进程终止\n//2. ...\n//3. 传递头文件sys/wait.h中声明的常量WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出\n```\n\n调用waitpid时程序不会阻塞。\n\neg.\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main () {\n\tint status;\n\tpid_t pid = fork();\n\t\n\tif (pid == 0) {\n\t\treturn 24;\n\t} else {\n\t\twhile (!waitpid(-1, &status, WNOHANG)) {\n\t\t\tsleep(3);\n\t\t\tprintf(\"sleep 3sec \\n\");\n\t\t}\n\t\tif (WIFEXITED(status)) {\n\t\t\tprintf(\"Child send %d \\n\", WEXITSTATUS(status));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n运行结果：\n\n![](/img/waitpid.h)\n\n### 信号处理\n\n#### signal函数\n\n信号注册函数\n\n```c\n#include <signal.h>\n\nvoid (*signal(int signo, void (*func)(int)))(int);\n\n//函数名: signal\n//参数：int signo, void (*func)(int)\n//返回类型：参数为int类型，返回void型函数指针\n```\n\n发生第一个参数代表的情况时，调用第二个参数所指向的函数。\n\nsignal函数中注册的部分特殊情况和对应的常数。\n\n- SIGALRM: 已通过调用alarm函数注册的时间\n- SIGINT: 输入CTRL+C\n- SIGCHLD: 子进程终止\n\n注册好信号后，发生注册信号时（注册的情况发生时），操作系统将调用该信号对应的函数。\n\n```c\n#include <unistd.h>\nunsigned int alarm(unsigned int seconds);\n```\n\n如果调用该函数的同时向它传递一个正整型参数，相应时间后（以秒为单位）将产生SIGALRM信号。若向该函数传递0，则之前对SIGALRM信号的预约将取消。\n\neg.\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <signal.h>\n\nvoid timeout(int sig) {\n\tif (sig == SIGALRM) {\n\t\tputs(\"Time out!\");\n\t}\n\talarm(2);\n};\n\nvoid keycontrol(int sig) {\n\tif (sig == SIGINT) {\n\t\tputs(\"CTRL+C\");\n\t}\n}\n\nint main () {\n\tint i;\n\tsignal(SIGALRM, timeout);\n\tsignal(SIGINT, keycontrol);\n\talarm(2);\n\t\n\tfor (int i = 0; i < 3; i++) {\n\t\tputs(\"waiting ...\");\n\t}\n\treturn 0;\n}\n\n```\n\n运行结果：\n\n![](/img/signal.png)\n\n> 发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程\n\n#### sigaction函数进行信号处理\n\n```c\n#include <signal.h>\n\nint sigaction (int signo, const struct sigaction *act, struct sigaction *oldact);\n```","tags":["C语言"]},{"title":"基于c语言的socket编程","url":"/2018/04/02/基于c语言的socket编程/","content":"\n本编主要是自己在用c语言搭建socket编程的细节 \n\n<!--more-->\n\n## tcp服务器端\n\n代码\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\nvoid error_handling(char *message);\n\nint main(int argc, char *argv[]) {\n\tint serv_sock;\n\tint clnt_sock;\n\tstruct sockaddr_in serv_addr;\n\tstruct sockaddr_in clnt_addr;\n\tsocklen_t clnt_addr_size;\n\n\tchar message[] = \"Hello World\";\n\t\n\tif (argc != 2){\n\t\tprintf(\"Usage : %s <port>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tserv_sock=socket(PF_INET, SOCK_STREAM, 0);//创建套接字（成功返回文件描述符，失败返回-1）\n\tif (serv_sock == -1) \n\t\terror_handling(\"socket() error\");\n\tmemset(&serv_addr, 0, sizeof(serv_addr));//每个字节都用0填充\n\tserv_addr.sin_family=AF_INET;//使用IPv4地址\n\tserv_addr.sin_addr.s_addr=htonl(INADDR_ANY);//ip地址\n\tserv_addr.sin_port=htons(atoi(argv[1]));//端口\n\n\tif (bind(serv_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1)//给创建好的套接字分配地址信息( 1P 地址和端口号 )（成功返回文件描述符，失败返回-1）\n\t\t\terror_handling(\"bind() error\");\n\t\n\tif (listen(serv_sock, 5) == -1) {////进入监听状态，等待用户发起请求\n\t\terror_handling(\"listen() error\");\n\t}\n\n\tclnt_addr_size=sizeof(clnt_addr);\n\t//接收客户端请求\n\tclnt_sock=accept(serv_sock, (struct sockaddr *)&clnt_addr, &clnt_addr_size);\n\tif (clnt_sock == -1)\n\t\terror_handling(\"accept() error\");\n\n\twrite(clnt_sock, message, sizeof(message)); //向客户端发送数据\n\t//关闭套接字\n\tclose(clnt_sock);\n\tclose(serv_sock);\n\treturn 0;\n}\n\nvoid error_handling(char *message) {\n\tfputs(message, stderr);\n\tfputc('\\n', stderr);\n\texit(1);\n}\n```\n\nInternet协议地址结构\n```c\nstruct sockaddr_in\n{\n\t__SOCKADDR_COMMON (sin_);\n\tin_port_t sin_port;\t\t\t/* Port number.  */\n\tstruct in_addr sin_addr;\t\t/* Internet address.  */\n\n\t/* Pad to size of `struct sockaddr'.  */\n\tunsigned char sin_zero[sizeof (struct sockaddr) -\n\t\t\t   __SOCKADDR_COMMON_SIZE -\n\t\t\t   sizeof (in_port_t) -\n\t\t\t   sizeof (struct in_addr)];\n};\nstruct sockaddr {\n\t__uint8_t\tsa_len;\t\t/* total length */\n\tsa_family_t\tsa_family;\t/* [XSI] address family */\n\tchar\t\tsa_data[14];\t/* [XSI] addr value (actually larger) */\n};\n\n```\n\n通用地址结构\n```c\ntypedef uint32_t in_addr_t;\nstruct in_addr\n{\n    in_addr_t s_addr;\n};\n```\n\n> AF 表示ADDRESS FAMILY 地址族，PF 表示PROTOCOL FAMILY 协议族，但这两个宏定义是一样的，所以使用哪个都没有关系。AF_INET（又称 PF_INET）是 IPv4 网络协议的套接字类型，AF_INET6 则是 IPv6 的；而 AF_UNIX 则是 Unix 系统本地通信。\n\n> INADDR_ANY就是指定地址为0.0.0.0的地址，这个地址事实上表示不确定地址，或“所有地址”、“任意地址”。 一般来说，在各个系统中均定义成为0值。\n\n> htonl、htons主机字节序转换为网络字节序\n\n## tcp 客户端\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\nvoid error_handling(char *message);\n\nint main(int argc, char* argv[]) {\n\tint sock;\n\tstruct sockaddr_in serv_addr;\n\tchar message[30];\n\tint str_len;\n\tif (argc != 3) {\n\t\tprintf(\"Usage : %s <IP> <port>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\n\tsock=socket(PF_INET, SOCK_STREAM, 0);//创建套接字\n\tif (sock == -1)\n\t\terror_handling(\"socket() error\");\n\n\tmemset(&serv_addr, 0, sizeof(serv_addr));//每字节都用0填充\n\tserv_addr.sin_family=AF_INET;//指定IPv4协议\n\tserv_addr.sin_addr.s_addr=inet_addr(argv[1]);//ip地址\n\tserv_addr.sin_port=htons(atoi(argv[2]));//端口号\n\n\tif (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1)//connect函数向服务器端发送连接请求（成功时返回 0，失败时返回-1）\n\t\terror_handling(\"connect() error\");\n\n\tstr_len=read(sock, message, sizeof(message)-1);//读取服务器传回的数据\n\tif (str_len == -1)\n\t\terror_handling(\"read() error\");\n\n\tprintf(\"Message from server : %s \\n\", message);\n\tclose(sock);//关闭套接字\n\treturn 0;\n}\n\nvoid error_handling(char *message) {\n\tfputs(message, stderr);\n\tfputc('\\n', stderr);\n\texit(1);\n}\n```\n","tags":["C语言"]},{"title":"入门docker","url":"/2018/03/29/入门docker/","content":"\n## 序言\n\n如果让我用一句话来形容docker的话。它简单易用，只是简单的操作拉取镜像和创建容器，然后你可以使用mysql、mongodb、redis、nginx等各类服务了。\n\n<!--more-->\n\n## 安装\n\n- [Mac](https://docs.docker.com/docker-for-mac/install/)\n- [Ubuntu](https://docs.docker.com/install/linux/docker-ce/ubuntu/)\n- [Windows](https://docs.docker.com/docker-for-windows/install/)\n\n## 命令\n\n查看Docker的版本\n\n```shell\ndocker version\n```\n\nDocker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组\n\n```shell\nsudo usermod -aG docker $USER\n```\n\n启动docker\n\n```shell\nsudo service docker start\n```\n\n下载镜像\n\n```shell\ndocker pull [imageName]\n```\n\n删除image镜像\n\n```shell\nsudo docker image rm [imageName]\n```\n\n列出docker镜像\n\n```shell\ndocker image ls\n```\n\n生成容器\t\n\n```shell\ndocker container run -p 3306:3306 --rm=true --name=mysql -v ./mysql:/etc/mysql -it -d mysql /bin/bash\n```\n\n参数:\n\t- -p容器的 3306 端口映射到本机的 3306 端口。\n\t- -it 容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。\n\t- mysql 镜像的名称\n\t- /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。\n\t- -v 挂载本地目录到容器目录\n\t- --rm=true 容器停止运行后，自动删除容器文件x\n\t- --name=** 给容器命名\n\t- -d 在后台运行\n\n列出容器\n\n```shell\ndocker container ls (--all)\n```\n\n删除容器\n```shell\ndocker container rm [containerID/containerName]\n```\n\n启动容器(前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。)\n\n```shell\ndocker container start [containerID]\n```\n\n终止容器运行\n```shell\ndocker container stop\n```\n\n进入一个正在运行的 docker 容器\n\n```shell\ndocker container exec -it [containerID] /bin/bash\n```\n\n用于从正在运行的 Docker 容器里面，将文件拷贝到本机\n```shell\ndocker container cp [containID]:[/path/to/file] .\n```","tags":["docker"]},{"title":"数据库的那些事","url":"/2017/12/09/数据库的那些事/","content":"\n## 管理数据库\n\n本篇将是自己在数据库方面的总结\n\n<!-- more -->\n\n### 添加用户\n\n#### MySql\n\n```shell\ncreate user `user`@`host` identified by `password`;\n```\n\n#### MongoDB\n\n```shell\ndb.createUser({user: \"\", pwd: \"\", roles: [\"readWrite\"]})\n```\n### 删除用户\n\n#### mongodb\n\n```shell\ndb.dropUser(\"sceley\")\n```\n\n### 更改密码\n\n#### mysql\n\n```shell\nmysqladmin -u root -p password\n```\n\n#### mongodb\n\n```shell\ndb.update(<username>, {\n\t\tpwd: <password>,\n\t\troles: [{role: <>, db: <dbname>}]\n\t});\n```\n\n### 删除用户\n\n#### mysql\n\n```shell\n\n```\n\n\n\n### 创建数据库\n\n#### mysql\n\n```shell\ncreate batabase `dbname`;\n```\n\n### 删除数据库\n\n#### mysql\n\n```shell\ndrop database `dbname`;\n```\n\n### 数据类型\n\n#### mysql\n\n```Java\nint/integer => 整型\ndouble => 双精度的浮点数\nfloat => 浮点\nchar => 定长字符串\nvarchar => 变长字符串\ntext => 长文本数据\ndate => 日期\n```","tags":["database"]},{"title":"浅谈Nodejs多进程","url":"/2017/11/17/浅谈Nodejs多进程/","content":"\n## 序言\n\nJavaScript是运行在单进程的单线程上，但是现在的计算机大多是多核CPU的。在nodejs中，为了充分利用多核cpu，引入了child_process和cluster这两个模块来开启多进程，来充分利用多核cpu。\n\n<!--more-->\n\n## 多进程\n\n### 创建子进程\n\n使用child_process模块提供的child_process.fork()函数提供我们实现进程的复制。\n\nworker.js\n\n```js\nconst http = require('http');\nconst server = http.createServer();\nserver.on('request', (req, res) => {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello World\\n');\n});\nserver.listen(Math.round((1 + Math.random()) * 1000, '127.0.0.1'));\n```\n\nmaster.js\n\n```js\nconst fork = require('child_process').fork;\nconst cpus = require('os').cpus();\nfor(let i = 0; i < cpus.length; i++) {\n    fork('./worker.js');\n}\n```\n\n上面的代码根据cpu的核数复制出相应Node进程数。\n\n这是著名的Master-Worker模式，又称主从模式。分为两种进程: 主进程、工作进程。这就是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务有多人开发完成，所以工作进程的稳定性值得开发者关注。\n\n![](/img/worker-master.png)\n\n### 进程间通讯\n\n通过send方法发送数据，通过监听message事件来接受发来的数据。通过消息传递内容，而不是共享或直接操作相关资源，这是较为轻量和无依赖的做法。\n\nexample\n\nparent.js\n\n```js\nconst cp = require('child_process');\nconst child = cp.fork('child.js');\nchild.on('message', msg => {\n    console.log(`parent receive message: ${msg}`);\n});\nchild.send({\n    hello: 'world',\n});\n```\n\nchild.js\n\n```js\nprocess.on('message', msg => {\n    console.log(`child receive message: ${msg}`);\n});\nprocess.send({\n    foo: 'bar'\n});\n```\n\n通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通讯，父进程和子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send传递消息。\n\n#### 进程间通信原理\n\n请查看《Node.js深入浅出》\n\n#### 句柄传递\n\n细节请查看《Node.js深入浅出》\n\n以发送的TCP服务器句柄为例，子进程收到消息后的还原过程如下所示:\n\n```js\nfunction (message, handle, emit) {\n\tlet server = new net.Server();\n\tserver.listen(handle, function () {\n\t\temit(server);\n\t});\n};\n```\n子进程根据message.type创建对应TCP服务器对象，然后监听到文件描述符上。\n\n> Node进程之间只有消息传递，不会真正地传递对象。\n> 多个应用监听相同的端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的。\n\n","tags":["NODEJS"]},{"title":"浅谈数据上传","url":"/2017/11/13/浅谈数据上传/","content":"\n## 序言\n\n本编总结一下自己在数据上传上的知识总结。\n\n<!--more-->\n\n## 数据上传\n\n### 判断是否有请求数据\n\nnodejs中，如果请求中带有内容部分(如POST请求，它具有报头和内容)，内容部分需要用户自行接受和解析。通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容。\n\n```js\nlet hasBody = req => 'transfer-encoding' in req.headers || 'content-length' in req.headers;\n```\n\nHTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所此:\n\n```js\nfunction (req, res) {\n    if(hasBody(req)) {\n        let buffers = [];\n        req.on('data', chunk => {\n            buffers.push(chunk);\n        });\n        req.on('end', () => {\n            req.rawBody = Buffer.concat(buffers).toString();\n            handle(req, res);\n        });\n    }\n}\n```\n\n### 表单提交\n\n#### POST\n\n默认的POST表单提交，请求头中的Content-Type字段值为application/x-www-form-urlencoded如下所示:\n\n```js\nContent-Type: application/x-www-form-urlencoded\n```\n\n它的报文体内容跟查询字符串相同:\n\n```js\nfoo=bar&baz=val\n```\n\n因此解析它很容易:\n\n```js\nlet handle = (req, res) {\n    if(req.headers['content-type'] === 'application/x-www-form-url') {\n        req.body = querystring.parse(req.rawbody);\n    }\n    todo(req, res);\n};\n```\n\n> get方式的表单提交，浏览器用x-www-form-urlencoded的编码方式把表单数据转换成一个字符串，然后添加到目标url地址后面。\n\n### 其他格式\n\nJSON类型=>application/json\n\nXML=>application/xml\n\n注意的是，在Content-Type中还可能附加如下所示的编码信息:\n\n```js\nContent-Type: application/json; charset=utf-8\n```\n\n所以在判断的时候，需要注意区分，如下所示\n\n```js\nlet mime = req => {\n    let str = req.headers['content-type'] || '';\n    return str.split(';')[0];\n}\n```\n\n解析JSON\n\n```js\nlet handle = (req, res) => {\n    if(mime(req) == 'application/json') {\n        try {\n            req.body = JSON.parse(req.rawBody);\n        } catch (e) {\n            res.writeHead(400);\n            req.end('Invalid JSON');\n            return;\n        }\n        todo(req, res);\n    }\n}\n```\n\n### ajax提交\n\nPOST提交默认的类型Content-Type是:\n\n```http\nContent-Type: text/plain;charset=UTF-8\n```\n\n通过.setRequestHeader(key, value)来设置请求头部信息。\n\n比如设置提交类型为application/json\n\n```js\nxhr.setRequestHeader('Content-Type', 'application/json');\n```\n> GET是通过拼接url提交请求数据的，所以它的请求头中不具有Content-Type字段的东西。\n\n### 附件上传\n\n附件上传数据类型为Content-Type: multipart/form-data\n\n通过指定表单属性enctype为multipart/form-data来设定表单提交的内容。\n\n```html\n<form enctype=\"multipart/form-data\">\n</form>\n```\n\n浏览器遇到multipart/form-data表单提交时，构造的请求报文与普通表单完全不同。首先它的报头中最为特殊的如下所示: \n\n```http\nContent-Length:575\nContent-Type:multipart/form-data; boundary=----WebKitFormBoundaryzMnpBNaj1z0QYAPt\n```\n\n![](/img/form-data.png)\n\n它代表本次提交的内容是由多部分构成，其中boundary=...指定的是每部分的分界符，...是随机生成的一段字符串报文体内容将通过在它前面添加--进行分割，报文结束时在它前后都加上--表示结束。\n\n解析\n\n```js\n(req, res) => {\n    if(hasBody(req)) {\n        let done = () => {\n            handle(req, res);\n        };\n        if(mime(req) === 'application/json') {\n            parseJSON(req, done);\n        } else if(mime(req) == 'application/xml') {\n            parseXML(req, res);\n        } else if(mime(req) == 'multipart/form-data') {\n            parseMultipart(req, done);\n        } else {\n            handle(req, res);\n        }\n    } \n}\n```","tags":["NODEJS"]},{"title":"浅谈HTTPS、HTTP2","url":"/2017/11/11/浅谈HTTPS、HTTP2/","content":"\n## 序言\n\n随着科技的发展，网络通讯对安全的要求越来越高。在如今，很多企业都在逐渐的把自己的网站升级为HTTPS、HTTP2，提高网站的安全可靠性。本编文章将总结自己在HTTPS、HTTP2上的学习。\n\n<!--more-->\n\n## HTTPS协议的介绍\n\n- HTTPS协议需要到CA申请证书。\n- HTTPS协议运行在SSL/TLS之上，SSL/TLS运行在TCP之上。\n- HTTPS使用443端口。\n- HTTPS可以方式有效防止运营商劫持。\n- HTTPS降低用户访问速度。SSL握手，HTTPS对速度会有一定程度的影响。\n\n## SPDY的介绍\n\n- 降低延迟，针对HTTP高延迟的问题，SPDY采用多路复用。(多路复用: 多个请求stream共享一个tcp连接)\n- 请求优先级。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。\n- header压缩。\n- 基于HTTPS的加密协议传输。\n- 服务器推送。(例如:网页有一个style.css请求，在客户端收到style.css数据的同时，服务器会将style.js的文件推送给客户端，当客户端再次尝试获取style.js时就可以直接从缓存中获取到)。\n- SPDY在SSL之上在HTTP之下。\n\n## HTTP2协议的介绍\n\nHTTP2.0可以说是SPDY的升级版。\n\n- 二进制协议，HTTP1.x的解析是基于文本，HTTP2.0的协议解析采用二进制格式。HTTP1.x的头信息肯定是文本，数据体可以是文本也可以是二进制；HTTP2.0是彻底\n- 多路复用。\n- header压缩，HTTP2.0使用encoder来减少传输的header大小，通讯双方各自cache一份header fileds表，即避免了重复header的传输，又减小了需要传输的大小。\n- 服务器推送。\n- 支持明文HTTP传输，而SPDY强制使用HTTPS。\n\n## 签名证书\n\n自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书。以下为生成私钥、生成CSR文件、通过私钥自签名生成证书的过程。\n\n```\n$ openssl genrsa -out ca.key 1024\n$ openssl req -new -key ca.key -out ca.csr\n$ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt\n```\n\n流程图如下\n\n![](/img/yourselfsign.png)\n\n接下来到服务器端，服务器端需要向CA机构申请签名证书。在申请签名证书之前依然是要创建自己的CSR文件。值得注意的是，这个过程中的Common Name要匹配服务器域名，否则在后续认证过程中会出错。如下是生成命令:\n\n```\n$ openssl genrsa -out server.key 1024\n$ openssl req -new -key server.key -out server.csr\n```\n\n![](/img/servercsr.png)\n\n得到CSR文件后，向我们自己的CA机构申请签名。签名需要CA的证书和私钥参与，最终颁发一个带有CA签名的证书，如下所示: \n\n```\n$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt\n```\n\n## HTTPS服务器\n\n```js\nconst https = require('https');//https模块\nconst fs = require('fs');\nconst opts = {\n    key: fs.readFileSync('./server.key'),//私钥\n    cert: fs.readFileSync('./server.crt'),//数字证书(签名证书)\n};\nconst server = https.createServer(opts, function (req, res) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello World');\n});\nserver.listen(8443);\n```\n\n客户端访问结果\n\n![](/img/https.png)\n\n## HTTP2服务器\n\n首先先下载第三方HTTP2\n\n```\n$ cnpm install http2 --save-dev\n```\n\n然后编写代码\n\n```js\nconst http2 = require('./node_modules/http2');\nconst fs = require('fs');\n\nconst options = {\n\tkey: fs.readFileSync('./server.key'),\n\tcert: fs.readFileSync('./server.crt'),\n};\n\nconst server = http2.createServer(options);\nserver.on('request', function (req, res) {\n\tres.writeHead(200, {'Content-Type': 'text/plain'});\n\tres.end('Hello World');\n});\nserver.listen(8443);\n```\n\n查看网络: \n\n![](/img/http2firefox.png)\n\n![](/img/http2chrome.png)\n\n## 通过Let'Encrypt获取第三方CA\n\n自己充当CA自颁发数字证书虽然方便，但是客户端并不信任该证书，因为客户端并不包含用于签名的CA证书。\n\n所以咱们使用Let'Encrypt机构给我们的服务器颁发证书。\n\n使用certbot获取证书，certbot的官方介绍:\n\nCertbot, previously the Let's Encrypt Client, is EFF's tool to obtain certs from Let's Encrypt, and (optionally) auto-enable HTTPS on your server.\n\n安装certbot\n\n```\n$ wget https://dl.eff.org/certbot-auto\n$ chmod a+x certbot-auto\n$ ./certbot-auto\n$ sudo certbot certonly\n```","tags":["HTTP"]},{"title":"浅谈SSL/TLS","url":"/2017/11/07/浅谈SSLTLS/","content":"\n## 序言\n\n在网络中，数据在服务器端和客户端之间传递，由于是明文传递的内容，一旦网络被人监控，数据就可能一览无余地展现在中间的窃听者面前。为此我们需要将数据加密后再进行网络传输，这样即使数据被截获和窃听，窃听者也无法知道数据的真实内容是什么。但是对于我们的应用层协议而言，如HTTP、FTP等，我们仍然希望能够透明地处理地处理数据，而无须操心网络传输过程中的安全问题。SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。最初的SSL应用层在Web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称TLS(Transport Layer Security，安全传输层协议)。\n\n<!--more-->\n\n## TLS/SSL\n\n### 密匙\n\nTLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥。客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要客户端的公钥进行加密，如此才能完成加密解密的过程，如下图:\n\n![](/img/ssltls.png)\n\n公私钥的非对称加密虽然好，但是网络中依然可能存在窃听的情况，典型的例子是中间人攻击。客户端和服务器端在交换公钥的过程中，中间人对客户端扮演服务器端的角色，对服务器端扮演客户端的角色，因此客户端和服务器端几乎感受不到中间人的存在。为了解决这种问题，数据传输过程中还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器。如果不能保证这种认证，中间人可能会将伪造的站点响应给用户，从而造成经济损失。中间人攻击示意图:\n\n![](/img/attack.png)\n\n为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数据证书包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。\n\n### 数字证书\n\n为了确保我们的数据安全，现在我们引入了一个第三方: CA(Certificate Authority, 数字证书认证中心)。CA的作用是为站点颁布证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名。\n\n为了得到签名证书，服务器端需要通过自己的私钥生成CSR(Certificate Signing Request，证书签名请求)文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构就能验证证书是否合法。\n\n通过CA机构颁发证书通常是一个繁琐的过程，需要付出一定的费力和精力。\n\n![](/img/checkca.png)\n\nCA机构将证书颁发给服务器端后，证书在请求的过程中会被发送给客户端，客户端需要通过CA的证书验证真伪。如果是知名的CA机构，它们的证书一般预装在浏览器中。\n\n### SSL作用\n\n- 所有信息都是加密传播，第三方无法窃听。\n- 具有校验机制，一旦被篡改，通信双方会立刻发现。\n- 配备身份证书，防止身份被冒充。\n\n### TLS/SSL协议的组成\n\n![](/img/TLSdetail.jpg)\n\nTLS/SSL协议又可以分为两层，上层分为三个子协议: HandShake，ChangeCiperSpec，Alert，下层为Recode。\n\n### SSL基本的运行机制\n\nSSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\n#### 公钥加密计算量太大，如何减少耗用的时间？\n\n解决方法：每一次对话（session），客户端和服务器端都生成一个\"对话密钥\"（session key），用它来加密信息。由于\"对话密钥\"是对称加密，所以运算速度非常快，而服务器公钥只用于加密\"对话密钥\"本身，这样就减少了加密运算的消耗时间。\n\n> 对称加密: 同一个密钥可以同时用作信息的加密和解密。\n> 非对称加密: 需要两个密钥：公开密钥（publickey）和私有密钥（privatekey），如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。\n\nSSL/TLS协议的基本过程是这样的：\n\n- 客户端向服务器端索要并验证公钥。\n- 双方协商生成\"对话密钥\"。\n- 双方采用\"对话密钥\"进行加密通信。\n\n上面过程的前两步，又称为\"握手阶段\"（handshake）。\n\n### TLS/SSL协议的握手过程\n\nHTTPS通信建立的过程其实是这样子的: 首先完成TCP三次握手，再进行TLS/SSL握手，以上两类握手完成后就建立了一个安全的通道，最后才进行HTTP通讯。\n\n五步握手: \n\n1. TLS/SSL客户端会发送一个成为“Client Hello”的消息包，里面包含了一串随机字符串（Client random）、SSL/TLS的版本和客户端支持的已经按优先次序排列的密码族。\n2. TLS/SSL服务器这边也会响应一个“Server Hello”的消息包，里面包含了一串随机字符串（Server random）、服务器选择的加密方式、服务器的数字证书、以及session ID。\n3. TLS/SSL客户端先是核实了服务器的数字证书后，使用服务器提供的公钥加密一串预主密钥(premaster secret)发送给服务器。\n4. TLS/SSL服务器使用自己的密钥解密获取预主密钥(premaster key)。\n5. 最后双方根据前面的协商好的加密方式，结合两串随机字符串(Client random, Server random)和预主密钥(premaster key)生成后续应用层通信使用的会话秘钥，至此完成了安全通道的建立，后续的消息通讯可以使用这个会话秘钥加密进行。\n![](http://image.beekka.com/blog/2014/bg2014092003.png)\n\n抓包看看，如下图:\n\nClient Hello包:\n\n![](/img/SSLdetail.png)\n\nServer Hello包:\n\n![](/img/ServerHello.png)\n\n抓到的TLS包:\n\n![](/img/packets.png)\n\n### 私钥的作用\n\n- 生成对话密钥一共需要三个随机数。\n- 握手之后的对话使用\"对话密钥\"加密（对称加密），服务器的公钥和私钥只用于加密和解密\"对话密钥\"（非对称加密），无其他作用。\n- 服务器公钥放在服务器的数字证书之中。\n\n从上面第二点可知，整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。这就是CloudFlare能够提供Keyless服务的根本原因。\n\n某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。\n\n![](http://image.beekka.com/blog/2014/bg2014092005.png)\n\n上图中，银行的服务器只参与第四步，后面的对话都不再会用到私钥了。\n\n### DH算法的握手阶段\n\n整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。\n\n虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的RSA算法，改为 Diffie-Hellman算法（简称DH算法）。\n\n采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。\n\n![](http://image.beekka.com/blog/2014/bg2014092007.png)\n\n上图中，第三步和第四步由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。\n\n### session的恢复\n\n握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。\n\n这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。\n\nsession ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的\"对话密钥\"，而不必重新生成一把。\n\n![](http://image.beekka.com/blog/2014/bg2014092009.png)\n\nsession ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。\n\n![](http://image.beekka.com/blog/2014/bg2014092011.png)\n\n上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。","tags":["HTTP"]},{"title":"数据结构之集合运算","url":"/2017/11/07/数据结构之集合运算/","content":"\n## 序言\n\n数据结构在编程中占据重要地位，程序的好坏与你的数据结构算法有重大的关系。而本篇则是关于我在写了一篇数据结构作业后的总结。\n\n<!--more-->\n\n## 包含的运算\n\n- 交集(∩)\n- 并集(∪)\n- 减集(-)\n\n## 代码部分\n\n线性表节点\n\n```c++\ntypedef struct LinkNode {\n    char data;//数据存储\n    struct LinkNode *next;//指向节点的指针\n} LinkNode, *LinkNodePtr;\n```\n\n线性表\n\n```c++\ntypedef struct LinkList {\n    LinkNodePtr head;//指向头部的指针\n    LinkNodePtr tail;//指向尾部的指针\n    int len;//线性表长度\n} LinkList;\n```\n\n初始化线性表\n\n```c++\nvoid InitList(LinkList &L) {\n    L.len = 0;//长度置零\n    L.head = L.tail = (LinkNodePtr)malloc(sizeof(LinkNode));//一个头结点\n    L.head->next = NULL;\n};\n```\n\n输入一个集合\n\n```c++\nvoid CreateList(LinkList &L, int n) {\n    char e;\n    int locate;\n    for(int i = 0; i < n; i++) {\n        cin>>e;//输入字符\n        if(e >= 'a' && e <= 'z') {//e的大小在a-z\n            locate = FindLocate(L, e);//有序链表，所以找出适合它大小的位置\n            ListInsert(L, locate, e);//插入到线性表中特定位置\n        }\n    }\n};\n```\n\n把元素插入表中，如果存在重复则不差入\n\n```c++\nbool ListInsert(LinkList &L, int locate, char e) {\n    LinkNodePtr q;//指针\n    q = L.head->next;//指向第一个节点\n    for(int i = 1; i < locate - 1; i++) {//直到指向locate - 1节点\n       q = q->next;//指针往后指\n    }\n    if(q->next != NULL && e == q->next->data) {//如果第locate位置的值等于e，则直接return\n        return false;\n    }\n    else {\n        LinkNodePtr p;//指针\n        p = (LinkNodePtr)malloc(sizeof(LinkNode));//申请一个节点\n        p->data = e;\n        p->next = q->next;\n        q->next = p;//在locate位置插入p\n        L.len++;\n        return true;    \n    }\n};\n```\n\n打印出一个集合\n\n```c++\nvoid ListTraverse(LinkList &L) {\n    LinkNodePtr p;//一个节点指针\n    p = L.head->next;//指向第一个节点\n    for(; p != NULL;) {\n        cout<<p->data;//打印数据\n        p = p->next;//指针往后指\n    }\n    cout<<endl;\n};\n```\n\n获取特定位置的元素\n\n```c++\nvoid GetElem(LinkList &L, int i, char &e) {\n    LinkNodePtr p;//一个节点指针\n    p = L.head->next;//指向第一个节点\n    int j = 1;\n    for(; j < i; j++) {//获取第i个节点的值\n        p = p->next;//指针往后指\n    }\n    e = p->data;\n};\n```\n\n把元素推入L中\n\n```c++\nbool ListAppend(LinkList &L, char e) {\n    LinkNodePtr p;\n    p = (LinkNodePtr)malloc(sizeof(LinkNode));\n    p->data = e;\n    L.tail->next = p;//往链表尾部加元素\n    L.tail = p;//把尾指针指向最后一个元素\n    L.tail->next = NULL;\n    L.len++;\n    return true;\n};\n```\n\n求减集\n\n```c++\nvoid Reduce(LinkList &La, LinkList &Lb, LinkList &Lc) {\n    int aLen = La.len;\n    int bLen = Lb.len;\n    bool equal;\n    char ae;\n    char be;\n    for(int i = 1; i <= aLen; i++) {\n        GetElem(La, i, ae);//获取La的元素\n        for(int j = 1; j <= bLen; j++) {\n            GetElem(Lb, j, be);//获取Lb的元素\n            equal = Equal(ae, be);\n            if(equal)\n                break;//一遇到一样的马上退出\n        }\n        if(!equal) {\n            ListAppend(Lc, ae);//La中与Lb中不一样的进入Lc\n        }\n    }\n};\n```\n\n![](/img/reduceset.png)\n\n求并集函数\n\n```c++\nvoid Sum(LinkList &La, LinkList &Lb, LinkList &Lc) {\n    int aLen = La.len;\n    int bLen = Lb.len;\n    for(int i = 1; i <= aLen; i++) {\n        char e;\n        GetElem(La, i, e);\n        ListAppend(Lc, e);//先把La中的元素都放进Lc\n    }\n    for(int i = 1; i <= bLen; i++) {\n        int locate;\n        char e;\n        GetElem(Lb, i, e);\n        locate = FindLocate(Lc, e);\n        ListInsert(Lc, locate, e);//然后把Lb中的元素插进，在ListInsert函数内部中判断重复\n    }\n};\n```\n\n求交集函数\n\n```c++\nvoid Intersection(LinkList &La, LinkList &Lb, LinkList &Lc) {\n    int aLen = La.len;\n    int bLen = Lb.len;\n    bool equal;\n    char ae;\n    char be;\n    for(int i = 1; i <= aLen; i++) {\n        GetElem(La, i, ae);//取La的元素\n        for(int j = 1; j <= bLen; j++) {\n            GetElem(Lb, j, be);//取Lb的元素\n            equal = Equal(ae, be);//判断他们是否相等\n            if(equal) {//相等则压入线性表Lc中\n                ListAppend(Lc, ae);\n                break;                \n            }\n        }\n    }\n};\n```","tags":["C++"]},{"title":"浅谈Cookie、Session、JWTS","url":"/2017/11/03/浅谈Cookie、Session、JWTS/","content":"\n## 序言\n\nHTTP是一个无状态的协议，现实中的业务却是需要一定的状态的，否则无法区分用户之间的身份。\n\n<!--more-->\n\n## Cookie\n\n### 初识Cookie\n\nHTTP是无状态的，如何标识和认证一个用户，最早的方案就是Cookie（曲奇饼）。它能记录服务器与客户端之间的状态，最早的用处就是用来判断用户是否第一次访问网站。在1997年形成规范RFC 2109，目前最新的规范为RFC 6065，它是一个由浏览器和服务器共同协作实现的规范。\n\nCookie的处理分为如下几步。\n\n- 服务器向客户端发送Cookie。\n- 浏览器将Cookie保存。\n- 之后每次浏览器都将会将Cookie发向服务器端。\n\n客户端发送的Cookie在请求报文的Cookie字段中。\n\nHTTP_Parser会将所有的报文字段解析到req.headers，那么Cookie就是req.headers.cookie。根据规范中的定义，Cookie值的格式是key-value; key2=value2形式，如果我们需要Cookie，解析它也十分容易。\n\n```js\nconst parseCookie = function (cookie) {\n    let cookies = {};\n    if(!cookie) {\n        return cookies;\n    }\n    let list = cookie.split(';');\n    for(let i = 0; i < list.length; i++) {\n        let pair = list[i].split('=');\n        cookies[pair[0].trim()] = pair[1];\n    }\n    return cookies;\n};\n```\n\n在业务逻辑代码执行之前，我们将其挂载在req对象上，让业务代码可以直接访问，如下所示:\n\n```js\nfunction (req, res) {\n    req.cookies = parseCookie(req.headers.cookie);\n    handle(req, res);\n}\n```\n\n这样我们的业务代码就可以进行判断处理了，如下所示:\n\n```js\nlet handle = function (req, res) {\n    res.writeHead(200);\n    if(req.cookies.isVisit) {\n        res.end('欢迎第一次来到动物园');\n    } else {\n        //TODO\n    }\n};\n```\n\n告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示:\n\n```js\nSet-Cookie: name=value; Path='/';Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;\n```\n\n其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项。\n\n- path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。\n- Expires和Max-Age是用来告知浏览器这个Cookie何时过期，如果不设置该选项，在关闭浏览器时将会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。\n- HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求过程中，依然会发送这个Cookie到服务器端。\n- Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行通话验证，如果是HTTP连接则不会传递该消息，所以很难被窃听到。\n\n知道Cookie在报文头中的具体格式后，下面我们将Cookie序列化成符合规范的字符串，相关代码如下。\n\n```js\nlet serialize = function (name, val, opt) {\n    let pairs = [name + '=' + encode(val)];\n    opt = opt || {};\n    if(opt.maxAge) pairs.push(`Max-Age=${opt.maxAge}`);\n    if(opt.domain) pairs.push(`Domain=${opt.domain}`);\n    if(opt.path) pairs.push(`Path=${opt.path}`);\n    if(opt.expires) pairs.push(`Expires=${opt.expires.toUTCString()}`);\n    if(opt.httpOnly) pairs.push(`HttpOnly`);\n    if(opt.secure) pairs.push(`Secure`);\n    return pairs.join(`; `);\n};\n```\n\n判断用户的状态，如下所示:\n\n```js\nlet handle = function (req, res) {\n    if(!req.cookies.isVisit) {\n        req.setHeader(`Set-Cookie, ${serialize('isVisit', 1)}`);\n        res.writeHead(200);\n        res.end('欢迎第一次来动物园');\n    } else {\n        res.writeHad(200);\n        res.end(`动物园再次欢迎你`);\n    }\n};\n```\n\n客户端收到这个带Set-Cookie的响应后，在之后的请求时会在Cookie字段中带上这个值。\n\nSet-Cookie是较少的，在报头中可能存在多字段。为此res.setHeader的第二个参数可以是一个数组，如下所示:\n\n```js\nSet-Cookie: foo=bar; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com\nSet-Cookie: foo=val; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com\n```\n\n### Cookie的性能影响\n\n由于Cookie的实现机制，一旦服务器端向客户端发送了设置Cookie的意图，除非Cookie过期，否则客户端每次请求都会发送这些Cookie到服务器端，一旦设置的Cookie过多，将会导致报头较大。大多数的Cookie并不需要每次都用上，因为这会造成宽带的部分浪费。在YSlow的性能优化规则中有这么一条:\n\n- 减小Cookie的大小\n- 为静态组件使用不同的域名\n- 减少DNS查询\n\n> 如果在域名的根节点设置Cookie，几乎所有的子路径下的请求都会带上这些Cookie\n\n### Session\n\nCookie并非完美，前文提及的体积过大就是一个显著的问题，最为严重的问题是Cookie可以在前后端进行修改，因此数据就极容易被篡改和伪造。\n\nSession的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。\n\n将每个客户端和服务器中的数据一一对应起来的两种实现方式。\n\n#### 基于Cookie来实现用户和数据的映射。(口令sessionid)\n\n```js\nlet sessions = {};\nlet key = 'session_id';\nlet EXPIRES = 20 * 60 * 1000;\n\nlet generate = function () {\n    let session = {};\n    session.id = (new Date()).getTime() + Math.random();\n    session.cookie = {\n        expires: (new Date()).getTime() + EXPIRES\n    };\n    sessions[session.id] = session;\n    return session;\n} ;\n```\n\n每一次请求到来时，检查Cookie中的口令与服务器端的数据，如果过期，就重新生成，如下所示:\n\n```js\nfunction (req, res) {\n    let id = req.cookies[key];\n    if(!id) {\n        req.session = generate();\n    } else {\n        let session = sessions[id];\n        if(session) {\n            if(session.cookie.expires > (new Date()).getTime() ) {\n                //更新超时时间\n                session.cookie.expires = Date.now() + EXPIRES;\n                req.session = session;\n            } else {\n                //如果超时了，删除旧数据，并重新生成。\n                delete sessions[id];\n                req.session = gennerate();\n            }\n        } else {\n            //如果session过期或口令不对，重新生成session\n            res.session = generate();\n        }\n    }\n    handle(req, res);\n};\n```\n\n把重新生成的Session响应给客户。\n\n```js\nlet writeHead = res.writeHead;\nres.writeHead = function () {\n    let cookies = res.getHeader('Set-Cookie');\n    let session = serialize(key, req.session.id);\n    cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies, session];\n    res.setHeader('Set-Cookie', cookies);\n    return writeHead.apply(this, arguments);\n};\n```\n\nSesion依赖于Cookie实现，是目前大多数Web应用的方案。\n\n#### 通过查询字符串来实现浏览器和服务器端数据对应\n\n略...\n\n### Session问题\n\n#### Session与内存\n\n#### Session与安全\n\n口令保存在客户端，口令可能会被盗取，口令可能会被伪造。\n\n对口令通过私钥加密进行签名。\n\n```js\nlet sign = function (val, secret) {\n    return val + '.' + crypto\n        .createHmac('sha256', secret)\n        .update(val)\n        .digest('base64')\n        .replace(/\\=+$/, '');\n};\n```\n\n在响应时，设置session值到Cookie中，如下所示:\n\n```js\nlet val = sign(req.sessionID, secret);\nres.setHeader('Set-Cookie', cookie.serialize(key, val));\n```\n\n接收请求时，检查签名\n\n```js\nlet unsign = function (val, secret) {\n    let str = val.slice(0, val.lastIndex('.'));\n    return sign(str, secret) == val ? str : false;\n};\n```\n\n### JSON Web Token (JWT)\n\n[jwt](https://jwt.io)官方介绍\n\nJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA.\n\n#### jwt的组成\n\n一个jwt实际上就是一个字符串，它由三部分组成，头部、载荷与签名。\n\n#### 头部(Header)\n\nThe header typically consists of two parts: the type of the token, which is JWT, and the hashing algorithm being used, such as HMAC SHA256 or RSA.\n\n用于描述关于该JWT的最基本信息，类型与签名所用的算法。\n\nfor example\n\n```js\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\nThen, this JSON is Base64Url encoded to form the first part of the JWT.\n\n#### 载荷(Payload)\n\nThe second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional metadata. There are three types of claims: reserved, public, and private claims.\n\n- Reserved claims: These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others.\n- Public claims: These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace.\n- These are the custom claims created to share information between parties that agree on using them.\n\nAn example of payload could be:\n\n```js\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\nThe payload is then Base64Url encoded to form the second part of the JSON Web Token\n\n#### 签名(signature)\n\nTo create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.\n\nFor example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way:\n\n```js\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```\n\nThe signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.\n\n#### 放它们到一起\n\nThe output is three Base64 strings separated by dots that can be easily passed in HTML and HTTP environments.\n\nThe following shows a JWT that has the previous header and payload encoded, and it is signed with a secret. \n\n![](https://cdn.auth0.com/content/jwt/encoded-jwt3.png)\n\n#### JWT是怎么样工作的\n\n![](https://cdn.auth0.com/content/jwt/jwt-diagram.png)\n\n#### JWT与Session的区别\n\n![](/img/session.png)\n\n![](/img/token.png)","tags":["NODEJS"]},{"title":"浅谈Node-WebSocket","url":"/2017/11/03/浅谈Node-WebSocket/","content":"\n## 序言\n\nWebSocket在客户端与服务器端的通讯中占有重要的地位，基于WebSocket客户端可以随时向服务器端发送数据，服务器也可以随时向客户端发送数据。多人在线聊天室就是基于WebSocket构建的。\n\n<!--more-->\n\n## 构建WebSocket服务\n\nWebsocket与Node之间的配合堪称完成完美，其理由有两条:\n\n- WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。\n- WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量客户端保持高并发连接。\n\n### WebSocket的介绍\n\n- 客户端与服务器端只建立一个TCP连接，可以使用更少的连接。\n- WebSocket服务器可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。\n- 有更轻量级的协议头，减少数据传送量。\n\n在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询(long-polling)或iframe流。\n\nWebSocket与HTTP相比，它更接近于传输层协议，它并没有在HTTP的基础上模拟服务器端的推送，而是在TCP上定义独立的协议。让人迷惑的部分在于它的握手部分是由HTTP完成的，使人觉得它可能是基于HTTP实现的。\n\nWebSocket协议主要分为两个部分: 握手和数据传输。\n\n### WebSocket握手\n\n客户端建立连接时，通过HTTP发起请求报文，如下所示:\n\n```HTTP\nGET /chat HTTP/1.1\nHost: server.exaple.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGh1IHNhbXBsZSBub25jZQ==\nSec-WebSocket-Protocol: chat，superchat\nSec-WebSocket-Version: 13\n```\n\n与普通的HTTP请求协议略有区别的部分在于如下这些协议头:\n\n```HTTP\nUpgrade: websocket\nConnection: Upgrade\n```\n\n上述两个字段表示请求服务器端升级协议头为WebSocket。其中Sec-WebSocket-Key用于安全校验: \n\n```HTTP\nSec-WebSocket-Key: dGh1IHNhbXBsZSBub25jZQ==\n```\n\nSec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与与字符串258EAFA5-E914-47DA-95CA-C5ABoDC85B11相连，形成字符串dGh1IHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5ABoDC85B11，然后通过sha1安全散列算法计算出结果后，在进行Base64编码，最后返回给客户端。这个算法如下所示:\n\n```js\nconst crypto = require('crypto');\nconst val = crypto.crateHash('sha1').update(key).digest('base64');\n```\n\n另外，下面两个字段指定子协议和版本号: \n\n```HTTP\nSec-WebSocket-Protocol: chat，superchat\nSec-WebSocket-Version: 13\n```\n\n服务器端在处理完请求后，响应如下报文\n\n```HTTP\nHTTP/1.1 101 Switching Protocols\nUpgrade: webSocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTaxaQ9kYGzzhZRbK+xOo=\nSec-WebSocket-Protocol: chat\n```\n\n上面的报文告之客户端正在更换协议，更新应用层协议为WebSocket协议，并在当前的套接字连接上应用新协议。剩余字段分别表示服务器端基于Sec-WebSocket-Key生成的字符串和选中的子协议。客户端将会校验Sec-WebSocket-Accept的值，如果成功，将开始接下来的数据传输。\n\n#### Node构建WebSocket客户端\n\n```js\nfunction parseUrl (url) {\n    let hostportpath = url.split('//')[1];\n    let host = hostportpath.split(':')[0];\n    let portpath = hostportpath.split(':')[1];\n    let port = portpath.split('/')[0];\n    return {\n        port,\n        host\n    };\n};\n\nconst WebSocket = function (url) {\n    //伪代码，解析ws://127.0.0.1:12010/updates，用于请求\n    this.options = parseUrl(url);\n    this.connect();\n};\nWebSocket.prototype.onopen = function () {\n    //TODO\n};\nWebSocket.prototype.setSocket = function (socket) {\n    this.socket = socket;\n};\nWebSocket.prototype.connect = function () {\n    let key = new Buffer(this.options.protocolVersion + '-' + Date.now()).toString('base64');\n    let shasum = crypto.createHash('sha1');\n    let expected = shasum.update(key + '258EAFA5-E914-47DA-95CA-C5ABoDC85B11').digest('base64');\n    let options = {\n        port: this.options.port,\n        host: this.options.hostname,\n        headers: {\n            'Connection': 'Upgrade',\n            'Upgrade': 'websocket',\n            'Sec-WebSocket-Key': key\n            'Sec-WebSocket-Version': 13\n        }\n    };\n    let req = http.request(options, (res, socket, upgradeHead) => {\n        this.setSocket(socket);\n        this.onopen();\n    });\n    req.end();\n};\n```\n\n#### Node构建WebSocket服务器\n\n```js\nconst http = require('http');\nconst crypto = require('crypto');\nconst server = http.createServer();\nserver.on('request', (req, res) => {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello World');\n});\nserver.listen(4000, 'localhost', () => {\n    console.log('http://localhost:4000');\n});\nserver.on('upgrade', (req, socket, upgradeHead) => {\n    let head = new Buffer(upgradeHead.length);\n    upgradeHead.copy(head);\n    let key = req.headers['sec-websocket-key'];\n    let shasum = crypto.createHash('sha1');\n    key = shasum.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11').digest('base64');\n    let headers = [\n        'HTTP/1.1 101 Switching Protocols',\n        'Upgrade: websocket',\n        'Connection: Upgrade',\n        'Sec-WebSocket-Accept: ' + key,\n    ];\n    \n    socket.setNoDelay(true);\n    socket.write(headers.concat('', '').join('\\r\\n'));\n    let data = '';\n    socket.on('data', chunk => {\n        data += chunk;\n    });\n    socket.on('end', () => {\n        console.log(data);\n        socket.write('nodejs');\n    });\n});\n```\n\n### WebSocket数据传输\n\n在握手顺利完成后，当前连接将不再进行HTTP的交互，而是开始WebSocket的数据帧协议，实现客户端与服务器端的数据交换。下图为协议升级过程示意图。\n\n![](/img/websocketprotocol.png)\n\n为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧(比如中间拦截破坏)，连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭。","tags":["NODEJS"]},{"title":"浅谈HTTP","url":"/2017/10/30/浅谈HTTP/","content":"## 序言\n\n作为一个WEB开发者，了解一些常用的协议是必须的，本编将总结自己在协议方面的学习。\n\n<!--more-->\n\n## WEB始祖HTTP\n\nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层，HTTP是建立在TCP协议上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如TCP建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。\n\nHTTP得以发展是W3C和IETF两个组织和作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。\n\n## HTTP的基本优化\n\n影响一个HTTP网络请求的因素主要有两个: 宽带和延迟。\n\n宽带: 如果说我们还停留在拨号上网的阶段，宽带可能成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得宽带得到极大的提升，我们就不再会担心有宽带而影响网速了。\n\n延迟: \n- 浏览器阻塞(HOL blocking):　浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有4个连接(这个根据浏览器内核不同可能会有所差异)，超过浏览器最大连接限制，后续请求就会被阻塞。\n- DNS查询(DNS Lookup): 浏览器需要知道目标服务器的IP才能建立连接。将域名解析为IP的这个系统就是DNS。这个通常可以利用DNS缓存结果达到减少这个时间的目的。\n- 建立连接(initial connection): HTTP是基于TCP协议的，浏览器最快也要在第三次握手时才能捎带HTTP请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较为明显，慢启动则对文件类大请求影响较大。\n\n## HTTP1.0与HTTP1.1\n\n最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用在现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。主要区别体现在:\n\n### 区别\n\n1. 缓存处理，HTTP1.0中主要使用header里的If-Modified-Since，Expires来作为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略，例如Entity，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。\n2. 宽带优化及网络连接的使用，HTTP1.0中，存在浪费宽带的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码206(Partial Content)，这样就方便了开发者自由的选择以便于充分选择利用宽带和连接。\n3. 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409(Conflict)表示服务器上的某个资源被永久性的删除。\n4. 长连接，HTTP1.1支持长连接和请求流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keey-alive，一定程度上弥补了HTTP1.O每次请求都要创建连接的缺点。\n5. Host头处理，在HTTP1.0中认为每一台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名(hostname)。但随着虚拟机技术的发展，在一台物理服务器上可以存在多个虚拟机，并且他们共享一个IP地址。HTTP1.1中的请求消息和响应消息都应该支持Hose头域，且请求消息中如果没有Host头域会报告一个错误(440 Bad Request)。\n\n### 问题\n\n1. HTTP1.0在传输数据时，每次都要重新建立连接，无疑增加了大量的延迟时间，特别是移动端表现更为突出。\n2. HTTP1.x在传输数据时，所有传输的内容都是明文的，无法保证数据的安全性。\n3. HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户的流量。\n4. 虽然HTTP1.x支持keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用同样会给服务器端带来大量的性能压力，并且对于单个文件被不断请求的服务（例如图片存放网站），keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。\n\n## HTTP\n\nHTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\nHTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。\n\nHTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n### HTTP 消息结构\n\n#### 客户端请求消息\n\n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。\n\n![](/img/httprequest.png)\n\n#### 服务器响应消息\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n![](/img/httpmessage.jpg)\n\n#### 实例\n\n客户端请求：\n\n```HTTP\n> GET / HTTP/1.1\n> Host: localhost:3000\n> User-Agent: curl/7.47.0\n> Accept: */*\n> \n```\n\n服务端响应:\n```HTTP\n< HTTP/1.1 200 OK\n< Content-Type: text/plain\n< Date: Tue, 31 Oct 2017 14:11:22 GMT\n< Connection: keep-alive\n< Transfer-Encoding: chunked\n< \nHello World\n```\n\n### HTTP请求方法\n\n- GET: 最常用的方法，通常用于请求服务器发送某个资源。\n- POST: 起初是用来向服务器输入数据，实际上通常用来把表单数据传输到服务器。\n- PUT: 与GET从服务器读取文档相反，PUT方法会向服务器写入文档。\n- DELETE: 请求服务器删除指定的资源。\n\n### HTTP状态码\n\nHTTP状态码:\n\n- 200 - 请求成功\n- 301 - 资源（网页等）被永久转移到其它URL\n- 404 - 请求的资源（网页等）不存在\n- 500 - 内部服务器错误\n\nHTTP状态码分类: \n\n- 1**\t信息，服务器收到请求，需要请求者继续执行操作\n- 2**\t成功，操作被成功接收并处理\n- 3**\t重定向，需要进一步的操作以完成请求\n- 4**\t客户端错误，请求包含语法错误或无法完成请求\n- 5**\t服务器错误，服务器在处理请求的过程中发生了错误\n\n### http模块\n\nNode的http模块包含了对HTTP处理的封装。在Node中，HTTP服务继承了TCP服务器(net模块)，它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装。\n\n![](/img/http.png)\n\nhttp模块将connection到request的过程进行了封装\n\n除此之外，http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿出连接中的传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头，触发request事件，调用用户的业务逻辑。该逻辑的示意图:\n\n![](/img/theprocessofhttp.png)\n\n#### HTTP请求\n\n对TCP连接的读操作，http模块将其封装为ServerRequest对象。请求报文头部将会通过http_parser进行解析。\n\n报头被解析后放置在req.headers属性上传递给业务逻辑以供调用。\n\n报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作，如下所示: \n\n```js\n(req, res) => {\n    //console.log(req.headers);\n    let buffers = [];\n    req.on('data', chunk => {\n        buffers.push(chunk);\n    });\n    res.on('end', () => {\n        let buffer = Buffer.concat(buffers);\n        res.end('Hello World');\n    });\n};\n```\nHTTP请求对象和HTTP响应对象是相对较底层的封装，现行的Web框架express就是在这两个对象的基础上进行高层封装完成的。\n\n#### HTTP响应\n\nHTTP响应封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的API为res.setHeader()和res.writeHead()。在上述报文示例中:\n\n```js\nres.writeHead(200, {'Content-Type': 'text/plain'});\n```\n\n其分为setHeader()和writeHead()两个步骤。它在http模块的封装下，实际生成如下的报文: \n\n```HTTP\n< HTTP/1.1 200 OK\n< Content-Type: text/plain\n```\n\n我们可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中。除此之外，http模块会自动帮你设置一些头信息，如下所示:\n\n```HTTP\n< Date: Tue, 31 Oct 2017 14:11:22 GMT\n< Connection: keep-alive\n< Transfer-Encoding: chunked\n<\n```\n\n响应结束后，HTTP服务器将可能会将当前连接用于下一个请求，或者关闭连接。值得注意的是，报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不会再生效。这有协议的特性决定的。\n\n### HTTP服务器\n\n```js\nconst http = require('http');\nconst server =  http.createServer((req, res) => {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.end('Hello World\\n');\n});\nserver.listen(8080, '127.0.0.1', () => {\n    console.log('server runing at http://localhost:127.0.0.1:1337/');\n});\n```\nNODE获取客户端IP:\n\n```js\nreq.headers['x-forwarded-for'] || req.connection.remoteAddress || req.socket.remoteAddress;\n```\n\nNODE获取客户端PORT:\n```js\nreq.connection.remotePort || req.socket.remotePort;\n```\n\n#### HTTP服务器的事件\n\n如同TCP服务一样，HTTP服务器也抽象了一些事件，以供应用层使用，同样典型的是，服务器也是一个EventEmitter实例。\n\n- connection事件: 在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接有可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。\n\n- request事件: 建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。\n\n- close事件: 与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以server.close()传递一个回调函数来快速注册该事件。\n\n- connect事件: 当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起请求的连接将会关闭。\n\n- upgrade事件: 当客户端要求升级连接协议时，需要和服务器协商，客户端会在请求头中带上Upgrade字段，服务器端会在接受到这样的请求时触发该事件。如果不监听该事件，发起该请求的连接将会被关闭。\n\n- clientError事件: 连接的客户触发error事件时，这个错误会传递到服务器端，此时触发该事件。\n\n### HTTP客户端\n\n> 从协议的角度来说，现在的应用，如浏览器，其实是一个HTTP的代理，用户的行为将会通过它转化为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上。HTTP服务只做两件事情: 处理HTTP请求和发送HTTP响应。\n\nhttp模块提供了一个底层API: http.request(options, connect)，用于构造HTTP客户端。\n\n```js\nconst options = {\n    hostname: '127.0.0.1',\n    port: 1334,\n    path: '/',\n    method: 'GET'\n};\nconst req = http.request(options, res => {\n    console.log('STATUS: ' + res.statusCode);\n    console.log('HEADERS: ' + JSON.stringify(res.headers));\n    res.setEncoding('uft8');\n    res.on('data', chunk => {\n        console.log(chunk);\n    });\n});\nreq.end();\n```\n\noptions参数决定了这个HTTP请求头中的内容，它的选项有如下这些。\n\n- host: 服务器的域名或IP地址，默认为localhost。\n- hostname: 服务器名称。\n- port: 服务器端口，默认为80。\n- socketPath: Domain套接字路径。\n- method: HTTP请求方法，默认为GET。\n- path: 请求路径，默认为/。\n- headers: 请求头对象。\n- auth: Basic认证，这个值将被计算成请求头中的Authorization部分。\n\n#### 客户端事件:\n\n- response: 与服务端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。\n- socket: 当底层连接池中建立的连接分配给当前请求对象时，触发该事件。\n- connect: 当客户端向服务器端发起CONNECT请求时，如果服务器响应了200状态码，客户端将会触发该事件。\n- upgrade: 客户端向服务器端发起Upgrade请求时，如果服务器响应了101 Switching Protocols状态，客户端将会触发该事件。\n- continue: 客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件。 \n\n> 在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完就触发response事件，同时传递一个响应对象以供操作ClientResponse。\n\n> TCP和UDP都属于网络传输协议，如果要构造高效的网络应用，就应该从传输层进行着手。\n","tags":["HTTP"]},{"title":"TCP、UDP、Socket总结","url":"/2017/10/28/TCP、UDP、Socket总结/","content":"\n## 序言\n\n本篇将开启我对各种协议的理解总结。\n\n<!--more-->\n\n## UDP与TCP与Socket\n\n### Socket\n\n#### 定义\n\n网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。\n\nSocket的英文原义是\"孔\"或\"插座\"。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作\"套接字\"，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。\n\nsocket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。\n\n![](/img/socket.jpg)\n\n#### Server-Client模型\n\n服务器，使用ServerSocket监听指定的端口，端口可以随意指定（由于1024以下的端口通常属于保留端口，在一些操作系统中不可以随意使用，所以建议使用大于1024的端口），等待客户连接请求，客户连接后，会话产生；在完成会话后，关闭连接。\n\n客户端，使用Socket对网络上某一个服务器的某一个端口发出连接请求，一旦连接成功，打开会话；会话完成后，关闭Socket。客户端不需要指定打开的端口，通常临时的、动态的分配一个1024以上的端口。\n\nSocket接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。要学Internet上的TCP/IP网络编程，必须理解Socket接口。Socket接口设计者最先是将接口放在Unix操作系统里面的。如果了解Unix系统的输入和输出的话，就很容易了解Socket了。网络的Socket数据传输是一种特殊的I/O，Socket也是一种文件描述符。Socket也具有一个类似于打开文件的函数调用Socket（），该函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。\n\n![](/img/socket.png)\n\n#### 常用的套接字类型2中折叠常用的Socket类型\n\n- 流式套接字（SOCK_STREAM）：面向连接的Socket，针对于面向连接的TCP服务应用。\n- 数据报式套接字（SOCK_DGRAM）：无连接的Socket，对应于无连接的UDP服务应用。\n\n### TCP\n\nTCP服务在网络应用中十分常见，目前大多数的应用都是基于TCP搭建而成。典型的HTTP、SMTP、IMAP等协议。\n\nTCP(传输控制协议)是面向连接的、传输可靠（保证数据正确性且保证数据顺序）、用于传输大量数据（流模式）、速度快，建立连接需要开销多（时间、系统资源）。\n\n#### TCP服务器端\n\n```js\nconst net = require('net');\nconst server = net.createServer(socket => {\n    socket.on('data', data => {\n        console.log(`接受到客户端发来的数据: ${data}`);\n        socket.write('你好');\n    });\n    socket.on('end', () => {\n        console.log('断开链接');\n    });\n    socket.write('欢迎光临nodejs应用\\n');\n});\nserver.listen(8124, () => {\n    console.log('server bound');\n});\n```\n\n#### TCP客户端\n\n```js\nconst net = require('net');\nconst client = net.connect({port: 8124}, () => {\n    console.log('client connected');\n    client.write('Hello World!');\n});\nclient.on('data', data => {\n    console.log(data.toString());\n    client.end();\n});\nclient.on('end',() => {\n    console.log('client disconnected');\n});\n```\n\n#### TCP服务事件\n\n##### 服务器事件\n\n对于通过net.createServer()创建的服务器而言，它是一个EventEmiter实例，它的自定以事件有如下几种。\n\n- listening: 在调用server.listen()绑定端口或Domain Socket后触发。\n- connection: 每个客户端套接字连接到服务器端时触发。\n- close:　当服务器关闭时触发, 在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。\n- error: 当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常。\n\n##### 连接事件\n\n服务器可以同时与多个客户端保持连接，对于每一个连接而言是典型的可写可读Stream对象。Stream对象可以用于服务器和客户端之间的通信，既可以通过data事件从一端读取另一端发来的数据，也可以通过write()方法从一端向另一端发送数据。它具有如下的自定义事件。\n\n- data: 当一端调用write()发送数据时，另一端将会触发data事件，事件传递的数据即是write()发送的数据。\n- end: 当连接中的任意一端发送了FIN数据时，将会触发该事件。\n- connect: 该事件用于客户端，当套接字与服务器端连接成功时会被触发。\n- drain: 当任意一端调用write()发送数据时，当前这段会触发该事件。\n- error: 当异常发生时，触发该事件。\n- timeout: 当一定事件后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置。\n\n另外，由于TCP套接字是可读可写的Stream对象，可以利用pipe()方法巧妙地实现管道操作，如下代码实现了一个echo服务器:\n```js\nconst net = require('net');\nconst server = net.createServer(socket => {\n    socket.write('Echo server \\r\\n');\n    socket.pipe(socket);\n});\nserver.listen(1337, '127.0.0.1');\n```\n\n### UDP\n\nUDP(用户数据包协议)面向非连接、传输不可靠、用于传输少量数据（数据报模式）、速度快，UDP传输的可靠性由应用层负责。\n\nUDP报头: \n\n![](https://p1.ssl.qhmsg.com/dr/220__/t013b598635950ce8ea.png)\n\nTCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通讯，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通讯，它虽然提供面向事务的简单不可靠的信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，如果音频、视频等。UDP目前应用很广泛，DNS服务器是基于它实现的。\n\n#### 创建UDP套接字\n\n创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接受数据。\n\n```js\nconst dgram = require('dgram');\nconst socket = dgram.createSocket('udp4');\n```\n\n####　创建UDP服务器端\n\n若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可。以下为一个完整的服务器端示例:\n\n```js\nconst dgram = require('dgram');\nconst server = dgram.createSocket('udp4');\nserver.on('message', (msg, rinfo) => {\n    console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);\n});\nserver.on('listening', () => {\n    let address = server.address();\n    console.log(`server listening ${address.address}:${address.port}`);\n});\nserver.bind(41234);\n```\n\n该套接字将接收所有网卡上41234端口上的消息。在绑定完成后，将触发listening事件。\n\n#### 创建UDP客户端\n\n创建一个客户端与服务器端进行对话，代码如下：\n\n```js\nconst dgram = require('dgram');\nconst message = new Buffer(\"深入浅出nodejs\");\nconst client = dgram.createSocket('udp4');\nclient.send(message, 0, message.length, 41234, 'localhost', (err, bytes) => {\n    client.close();\n});\n```\n\n当套接字对象用在客户端时，可以调用send()方法发送消息到网络中。send()方法的参数如下:\n\n```js\nsocket.send(buf, offset, length, port, address, [callback]);\n```\n\n这些参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调。与TCP套接字的write相比,send()方法的参数列表相对复杂，但是它更灵活的地方在于可以随意发送数据到网络中的服务器端，而TCP如果要发送数据给另一个服务器端，则需要重新通过套接字构造新的连接。\n\n#### UDP套接字事件\n\nUDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream实例。它具备如下自定义事件:\n\n- message: 当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址消息。\n- listening: 当UDP套接字开始侦听时触发该事件。\n- close: 调用close()方法时触发该事件，并不在触发message事件。如需再次触发message事件，重新绑定即可。\n- error: 当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。","tags":["HTTP"]},{"title":"JavaScript常用设计模式","url":"/2017/10/28/JavaScript常用设计模式/","content":"\n## 序言\n\n模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的JavaScript应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。\n\n<!-- more-->\n\n## 常用的设计模式\n\n- 工厂模式\n- 单体模式\n- 模块模式\n- 代理模式\n- 策略模式\n- 发布-订阅模式\n- 观察者模式\n\n### 工厂模式\n\n工厂模式是为了解决多个类似的对象声明的问题，也就是为了解决实例化对象产生的重复问题。\n\n```js\nfunction CreatePerson(name, age, sex) {\n    let obj = new Object();\n    obj.name = name;\n    obj.age = age;\n    obj.sex = sex;\n    obj.sayName = function () {\n        return this.name;\n    };\n    return obj;\n};\n\nlet person1 = new CreatePerson('xiaowang', '20', 'boy');\nlet person2 = new CreatePerson('mary', '18', 'girl');\nconsole.log(person1.name);//xiaowang\nconsole.log(person2.name);//may\n\n//返回都是object，无法识别对象的类型，不知道他们是哪个对象的实例。\nconsole.log(typeof person1);//object\nconsole.log(typeof person2);//object\nconsole.log(person1 instanceof Object);//true\n```\n\n> 优点: 能解决多个相似的问题\n> 缺点: 不能知道对象识别的问题(对象的类型不知道)\n\n### 单体模式\n\n单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象。如果它可以被实例化，那么它只能被实例化一次。\n\n对象字面量来创建单体模式\n\n```js\nlet Singleton = {\n    attr1: 1,\n    attr2: 2,\n    method1: function () {\n        return this.attr1;\n    },\n    method2: function () {\n        return this.attr2;\n    }\n};\n```\n\n单体化模式\n\n```js\nlet Singleton = function (name) {\n    this.name = name;\n};\nSingleton.prototype.getName = function () {\n    return this.name;\n};\nlet getInstance = (function () {\n    let instance = null;\n    return function (name) {\n        if(!instance) {\n            instance = new Singleton(name);\n        }\n        return instance;\n    }\n})();\nlet a = getInstance('aa');\nlet b = getInstance('bb');\nconsole.log(a == b);//true\nconsole.log(a.getName());//aa\nconsole.log(b.getName());//aa\n```\n\n单体模式的优点:\n\n- 可以来用划分命令空间，减少全局变量。\n- 使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。\n\n### 模块模式\n\n模块模式的思路是为单体模式添加私有变量和私有方法能够减少全局变量的使用。\n\n```js\nlet Single = (function () {\n    //私有变量\n    let privateNum = 112;\n    //公有变量\n    let publicNum = 110;\n    //私有函数\n    function privateFunc() {\n        //业务逻辑代码\n    };\n    //公有函数\n    function publicFunc() {\n        //业务逻辑代码\n    }；\n    //返回一个对象包含公有方法和属性\n    return {\n        publicNum,\n        publicFunc\n    };\n});\n```\n\n### 代理模式\n\n```js\n//声明一个妹子\nlet AGirl = function (name) {\n    this.name = name;\n};\n//声明一个男孩\nlet ABoy = function (girl) {\n    this.girl = girl;\n    //送礼物给一个妹子\n    this.sendMarriageGift = function (gift) {\n        return 'Hi ' + this.girl.name + ', a　boy 送你一个礼物: ' + gift;\n    };\n};\n//代理人\nlet Proxy = function (girl) {\n    this.girl = girl;\n    this.sendGift = function (gift) {\n        new ABoy(girl).sendMarriageGift(gift);\n    };\n};\n//初始化\nlet proxy = new Proxy(new AGirl('漂亮妹子'));\nproxy.sendGift('结婚戒');//Hi 漂亮妹子, a boy 送你一个礼物：　结婚戒\n```\n\n### 策略模式\n\n```js\nconst stragegy = {\n    'A': function (salary) {\n        return salary * 4;\n    },\n    'B': function (salary) {\n        return salary * 3;\n    },\n    'C': function (salary) {\n        return salay * 2;\n    }\n};\nconst calculateBount = function (level, salary) {\n    return stragegy[level](salary);\n};\nconsole.log(calculateBount('A', 10000));\n```\n\n### 观察者模式\n\n根据状态的变化主动触发观察者队列、hashMap的回调行为。redux中使用\n\n```js\nfunction Observer() {\n    this.observers = [];\n};\nObserver.prototype.subscribe = function (fn) {\n    this.observers.push(fn);\n};\nObserver.prototype.unsubscribe = function (fn) {\n    this.observers = this.observers.filter(_fn => {\n        return _fn !== fn;\n    });\n};\nObserver.prototype.update = function (val) {\n    this.observers.forEach(fn => {\n        fn(val);\n    });\n};\nconst Ob = new Observer();\nconst fn1 = function (val) {\n    console.log(`我是${val}`);\n};\nconst fn2 = function (val) {\n    console.log(`它是${val}`);\n};\nOb.subscribe(fn1);\nOb.subscribe(fn2);\nOb.update('nodejs');\nOb.unsubscribe(fn2);\nOb.update('JavaScript');\n```\n\n### 发布订阅模式\n\n```js\nfunction PubSub() {\n    this.eventPool = [];\n};\nPubSub.prototype.publish = function(topicName, ...arg) {\n    this.eventPool[topicName] && this.eventPool[topicName].forEach(callback => {\n        callback(arg);\n    });\n};\nPubSub.prototype.subscribe = function(topicName, callback) {\n    let topic = this.eventPool[topicName];\n    if(!topic)\n        this.eventPool[topicName] = [];\n    this.eventPool[topicName].push(callback);\n};\nlet pub = new PubSub();\npub.subscribe('node', function (data) {\n    console.log(`收到:${data}`);\n});\npub.publish('node', 'nodejs');\n```","tags":["JavaScript"]},{"title":"浅谈JS内存","url":"/2017/10/26/浅谈JS内存/","content":"\n## 序言\n\n与前端不同，后端是直面服务器的，所以对性能的要求更高，对内存有更高的要求。如果存在内存泄漏，跟随着时间的流逝，内存泄漏越来越多，程序运行也会越来越慢，最终崩溃。所以要想深入学习node，控制内存的使用是至关重要的。\n\n<!-- more -->\n\n## 内存管理\n\n### 概述\n\nC语言有低级的原生内存管理原语，像malloc()和free()，开发人员使用这些原语可以显式分配和释放内存。\n\nJavaScript在创建变量时会自动分配内存，并在这些变量不被使用时自动释放内存－－－垃圾回收机制。\n\n### 内存生命周期\n\nAllocate => Use Memory => Release memory\n\n- 分配内存\n- 使用内存\n- 释放内存\n\n### 内存\n\n- 所有的变量和程序中用到的数据。\n- 程序的代码，包括操作系统的代码。\n\n编译器和操作系统共同帮助开发者完成大部分的内存管理。\n\n#### 动态分配\n\n#### JavaScript中的内存分配\n\nJavaScript在开发者声明值的时候自动分配内存。\n\n```js\nvar n = 374;//为数值分配内存\nvar s = 'sessionstack';//为字符串分配内存\nvar o = {\n    a: 1,\n    b: null,\n};//为对象和它包含的值分配内存\nvar a = [1, null, 'str'];//为数组和它包含的值分配内存\nfunction f (a) {\n    return a + 3;\n};//为函数(可调用的对象)分配内存\n//函数表达式也会分配一个对象\n```\n\n#### 垃圾收集\n\n##### 引用计数\n\n##### 标记清除算法","tags":["JavaScript"]},{"title":"浅谈curry化","url":"/2017/10/25/浅谈curry化/","content":"\n## 序言\n\n在函数式编程中我了解到了柯里化，并且觉得它很有意思，所以对它的实现原理进行了探索，其中难点还真不少。\n\n<!--more-->\n\n## curry化的概念\n\ncurry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n你可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用\n\n## curry化的实现代码\n\n```js\nlet sub_curry = function(fn) {\n    let args = [].slice.call(arguments, 1);\n    return function() {\n        return fn.apply(this, args.concat(Array.from(arguments)));\n    };\n};\nlet curry = function(fn, len) {\n    len = len || fn.length;\n    return function () {\n        if(arguments.length < len) {\n            let combined = [fn].concat(Array.from(arguments));\n            return curry(sub_curry.apply(this, combined), len - arguments.length);\n        }\n        else {\n            return fn.apply(this, arguments);\n        }\n    };\n};\n```\n\n## curry化使用的哪些知识点\n\n- 闭包\n- 递归\n\n## curry难点解析\n\n难点是下面这句话的调用\n\n```js\nsub_curry.apply(this, combined)\n```\n\n这个语句返回一个闭包，并且这个闭包中的fn是前面一个函数。\n\n附上一张图理解。\n\n![](/img/closure.png)\n\n这个最终的目的就是把所有的参数传递给fn调用\n\n附上演示的栗子:\n\n```js\nlet multiply = function (a, b, c) {\n    return a * b * c;\n};\nlet multiplyCurry = curry(multiply);\nconsole.log(multiplyCurry(3)(2)(4));\n//=>24\n```\n\n> 另一种实现\n\n```js\n// 另一种简单实现，参数只能从右到左传递\nfunction createCurry(func, args) {\n    var arity = func.length;\n    var args = args || [];\n    return function() {\n        var _args = [].slice.call(arguments);\n        [].push.apply(_args, args);\n        // 如果参数个数小于最初的func.length，则递归调用，继续收集参数\n        if (_args.length < arity) {\n            return createCurry.call(this, func, _args);\n        }\n        // 参数收集完毕，则执行func\n        return func.apply(this, _args);\n    };\n};\n```","tags":["JavaScript"]},{"title":"FP-Pointfree编程指南","url":"/2017/10/25/FP-Pointfree编程指南/","content":"\n## 序言\n\n<!--more-->\n\n## Pointfree\n\n### Pointfree概念\n\npointfree 模式指的是，永远不必说出你的数据\n\n不使用所要处理的值，只合成运算过程。\n\nexample\n\n```js\nlet compose = function (f, g) {\n    return function (x) {\n        return f(g(x));\n    };\n};\nlet addOne = x => x + 1;\nlet square = x => x * x;\nlet addOneSquare = compose(square, addOne);\naddOneSquare(2);\n//=>9\n```\n\n上面一个栗子，把两个函数组合，然后求值。\n\naddOneThenSquare是一个合成函数。定义它的时候，根本不需要提到要处理的值，这就是 Pointfree。\n\n### Pointfree的本质\n\nPointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。\n\nexample: 读取对象的role属性，不要直接写成obj.role, 而是要把这个操作封装成函数。\n\n```js\nlet prop = (p, obj) => obj[p];\nlet propRole = curry(prop)('role');\n```","tags":["JavaScript"]},{"title":"浅谈TCP/IP","url":"/2017/10/21/浅谈TCP-IP/","content":"\n## 序言\n\n作为一名计算机科学与技术的工科生，了解计算机网络基础是必须的。网络通讯遍布在我们身边，从本博客开始，将启航我在计算机网络上的系列学习。\n\n<!--more-->\n\n## OSI七层模型\n\nOSI 模型(开放系统互联模型)是一个由国际标准化组织(ISO)提出概念模型,试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。\n\nOSI　将计算机网络体系结构划分为七层,每层都可以提供抽象良好的接口。了解 OSI 模型有助于理解实际上互联网络的工业标准——TCP/IP 协议。\n\n七层协议，从下往上\n\n1. 物理层(网络物理硬件)\n2. 链路层(网络特有的链路接口)\n3. 网络层(IP)\n4. 传输层(TCP/UDP)\n5. 会话层(通信连接/维持会话)\n6. 表示层(加密/解密等)\n7. 应用层(HTTP、SMTP、IMAP等)\n\n附上三个图促进理解\n\n![OSI图片](/img/OSI1.jpg)\n\n![OSI图片](/img/OSI2.gif)\n\n![OSI图片](/img/OSI3.png)\n\n> 物理地址，又称网卡的硬件MAC地址(处于数据链路层)负责局域网通讯，IP地址(处于网络层)负责外网通讯\n\n## TCP/IP\n\n### 定义\n\nTCP/IP模型也被称作DoD模型(Department of Defense Model)。TCP/IP字面上代表了两个协议：TCP（传输控制协议）和IP（网际协议）。但TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族。从协议分层模型方面来讲，TCP/IP由四个层次组成:网络接口层、网络层、传输层、应用层。TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。\n\n> OSI模型所分的七层,在实际应用中,往往有一些层被整合,或者功能分散到其他层去。\n\n> TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。\n\n> TCP/IP 的设计,是吸取了分层模型的精华思想——封装。每层对上一层提供服务的时候,上一层的数据结构是黑盒,直接作为本层的数据,而不需要关心上一层协议的任何细节\n\n四层模型:\n\n![tcp/ip四层模型图](/img/tipcip&osi.png)\n\n![tcp/ip图片](/img/application.png)\n\nTCP/IP 分层模型的分层以以太网上传输 UDP 数据包如图所示\n\n![tcp/ip图片](/img/TCPIP.png)\n\n各层中的协议\n\n![](/img/protocol.jpg)\n\n![tcpip通讯流](/img/tcpipstream.jpg)\n\n基于tcp的文件传输(ftp－port21)\n\n![](/img/datapackage.png)\n\n基于TCP和UDP的数据封装及解析示例如下：\n\n![](/img/package.jpg)\n\nTCP数据包\n\n![](/img/tcppackage.jpg)\n\ntcp在真正连接前要经过三次握手，断开连接需要经过四次挥手\n\nTCP三次握手\n\n![](/img/threeShake.png)\n\nTCP四次挥手\n\n- 第一次挥手\n\n    主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。\n\n- 第二次挥手\n\n    被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）\n\n- 第三次挥手\n\n    被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了\n\n- 第四次挥手\n\n    主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。\n\n![四次挥手图片](/img/waved.jpg)\n\n\n### IP数据包\n\n以太网数据包(packet)的大小是固定的，最初是1518字节，后来增加到1522字节。其中，1500字节是负载(pyload)，22字节是头部信息(head)。\n\nIP数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以IP数据包的负载最多为1480字节。\n\nIP数据包\n\n![paket数据包](/img/ipPackage.png)\n\n> IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。\n\nTCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。\n\n因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。\n\n![packet数据包](/img/packet2.png)\n\n（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）","tags":["HTTP"]},{"title":"浅谈MVX","url":"/2017/10/21/浅谈MVX/","content":"\n## 序言\n\nMVC框架最早出现在Java领域，然后慢慢的在前端开发中也被提到，后来又出现了MVP，以及现在最成熟的MVVM\n\n<!--more-->\n\n## MVX\n\n### MVC\n\nMVC（Model-View-Controller）是应用最广泛的软件架构之一，一般MVC分为: Model(模型)、Controller(控制器)和View(视图)。这主要是基于分层的目的，让彼此的职责分开。\n\n控制器（Controller），一组行为的集合。(业务逻辑)\n\n模型（Model），数据相关的操作和封装。(数据保存)\n\n视图（View），视图的渲染。(用户界面)\n\nView一般通过Controler来和Model进行联系的。Controller是Model和View的协调者，View和Model不直接联系。基本联系都是单项的。\n\n![](http://image.beekka.com/blog/2015/bg2015020105.png)\n\n1. View 传送指令到Controler\n2. Controller 完成业务逻辑，要求 Model 改变状态\n3. Model 将新的数据发送到　View，用户得到反馈\n\n接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。\n\n![](http://image.beekka.com/blog/2015/bg2015020106.png)\n\n另一种是直接通过controller接受指令。\n\n![](http://image.beekka.com/blog/2015/bg2015020107.png)\n\n### MVP\n\nMVP模式将 Controller改名为Persenter,　同时改变了通信方向。\n\n![](http://image.beekka.com/blog/2015/bg2015020109.png)\n\n1. 各部分之间的通信，都是双向的。\n2. View 与 Model不发生联系。都通过Persenter传递。\n3. View 非常薄, 不部署任何业务逻辑，称为\"被动视图\"，即没有任何主动性，而Persenter非常厚，所有逻辑都部署在那里。\n\n### MVVM\n\nMVVM模式将Persenter改名为ViewModel，基本上与MVP完全一致\n\n![](http://image.beekka.com/blog/2015/bg2015020110.png)\n\n唯一的区别是，它采用双向绑定(data-binding): View的变动，自动反映在ViewModel，反之亦然。Angular和Vue采用这种模式。","tags":["框架模式"]},{"title":"浅谈Web缓存","url":"/2017/10/19/浅谈Web缓存/","content":"\n## 序言\n\n在开发当中，性能至关重要，然而判断一个网站的性能最直观的就是看到网页打开的速度。其中提高网页反应速度的一个方式就是使用缓存。一个优秀的缓存策略可以缩短网页请求的距离，减少延迟，使缓存文件得到重复利用，减少冠带，降低网络负荷。\n\n<!-- more -->\n\n## 缓存分类\n\n- 数据库缓存\n- 代理服务器缓存\n- CDN缓存\n- 浏览器缓存\n\n### 浏览器缓存\n\n页面的缓存状态是由header决定的，header的参数有四种。\n\n#### Cache-Control\n\n其优先级要比Expires高\n\n##### max-age\n\n单位为s，指定设置缓存最大的有效时间，定义时间的长短。当浏览器向服务器发送请求过后，在max-age这段时间里浏览器就不会再向服务器发送请求了。\n\nexample:\n\n服务器设置缓存。\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst server = http.createServer();\nserver.on('request', (req, res) => {\n    if(req.url == '/') {\n        res.writeHead(200, {'Content-Type': 'text/html'});\n        new fs.createReadStream('./index.html').pipe(res);\n    } else if(req.url == '/request') {\n        res.setHeader('Cache-Control', `max-age=${60*1}`);//1minutes\n        res.writeHead(200, {'Content-Type': 'text/plain'});\n        res.end('Hello World');\n    } else if(req.url == '/favicon.ico') {\n        res.end();\n    }\n});\nserver.listen(7000, 'localhost');\n```\n\n客户端通过ajax请求数据，浏览器刷新的方式，cache缓存不没有效果的，所以要通过不刷新的ajax方式才能看到效果。\n\n![](/img/cache-control.png)\n\n##### s-maxage\n\n单位为s，同max-age，只是用于共享缓存(比如CDN缓存)\n\n比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说max-age用于普通的缓存，而s-maxage用于代理缓存。\n如果存在s-maxage，则会覆盖掉max-age和Expires header\n\n##### public\n\n指定响应会被缓存，并且在多用户间共享。也就是下图的意思。如果没有指定public还是private，则默认为public\n\n##### private\n\n响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private\n\n##### no-cache\n\n```js\nres.setHeader('Cache-Control', 'no-cache');\n```\n\n设置了no-cache之后并不代表浏览器不缓存，而是在使用缓存前要向服务器确认资源是否被更改。\n\n##### no-store\n\n绝对禁止缓存，一看就知道如果用了这个命令当然就是不会进行缓存，每次请求资源都要从服务器重新获取\n\n#### Expires\n\n单位为毫秒ms，缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。\n\n```js\nlet expires = new Date(Date.now() + 1000 * 60 * 1).toUTCString();//1minute\nres.setHeader('Expires', expires);\n```\n\n![](/img/expires.png)\n\n#### Last-modified\n\n服务器端文件的最后修改时间，需要和cache-control共同使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送If-Modified-Since报头，询问Last-Modified时间点之后资源是否被修改过。如果没有修改，则返回码为304，使用缓存；如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。\n\nhandle函数\n\n```js\nconst handle = (req, res, filename) => {\n\tfs.stat(filename, (err, stat) => {\n\t\tlet lastModified = stat.mtime.toUTCString();\n\t\tif(lastModified == req.headers['if-modified-since']) {\n\t\t\tres.writeHead(304, 'Not Modified');\n\t\t\tres.end();\n\t\t} else {\n\t\t\tres.setHeader('Last-Modified', lastModified);\n\t\t\tres.writeHead(200, {'Content-Type': 'text/html'});\n\t\t\tnew fs.createReadStream(filename).pipe(res);\n\t\t}\n\t});\n};\n```\n\n#### ETag\n\n根据实体内容生成一段hash字符串，标识资源的状态，由服务端产生。浏览器会将这串字符串传回服务器，验证资源是否已经修改。\n\n```js\nconst getHash = (str) => {\n\tlet shasum = crypto.createHash('sha1');\n\treturn shasum.update(str).digest('base64');\n};\n\nconst handle = (req, res, filename) => {\n\tfs.readFile(filename, (err, filedata) => {\n\t\tlet hash = getHash(filedata);\n\t\tlet noneMatch = req.headers['if-none-match'];\n\t\tif (hash == noneMatch) {\n\t\t\tres.writeHead(304, 'Not Modified');\n\t\t\tres.end();\n\t\t} else {\n\t\t\tres.setHeader('ETag', hash);\n\t\t\tres.writeHead(200, {'Content-Type': 'text/html'});\n\t\t\tres.end(filedata);\n\t\t}\n\t});\n};\n```","tags":["NODEJS"]},{"title":"新的hexo","url":"/2017/10/18/新的hexo/","content":"\n## 新的博客\n\n哎，前段时间为了装Ubuntu系统，在备份中不小心丢失了那些以前写的原生的博客资源。从本站开始，我要重新启航自己的博客生活，希望能和大家一起分享自己的技术心得，我们一起学习成长。一步一步提高自己的技能点，早日实现自己的技术之梦。","tags":["hexo"]}]