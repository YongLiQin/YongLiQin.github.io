---
title: 数据结构之集合运算
date: 2017-11-07 13:51:50
tags: C++
categories: dataStructure
---

## 序言

数据结构在编程中占据重要地位，程序的好坏与你的数据结构算法有重大的关系。而本篇则是关于我在写了一篇数据结构作业后的总结。

<!--more-->

## 包含的运算

- 交集(∩)
- 并集(∪)
- 减集(-)

## 代码部分

线性表节点

```c++
typedef struct LinkNode {
    char data;//数据存储
    struct LinkNode *next;//指向节点的指针
} LinkNode, *LinkNodePtr;
```

线性表

```c++
typedef struct LinkList {
    LinkNodePtr head;//指向头部的指针
    LinkNodePtr tail;//指向尾部的指针
    int len;//线性表长度
} LinkList;
```

初始化线性表

```c++
void InitList(LinkList &L) {
    L.len = 0;//长度置零
    L.head = L.tail = (LinkNodePtr)malloc(sizeof(LinkNode));//一个头结点
    L.head->next = NULL;
};
```

输入一个集合

```c++
void CreateList(LinkList &L, int n) {
    char e;
    int locate;
    for(int i = 0; i < n; i++) {
        cin>>e;//输入字符
        if(e >= 'a' && e <= 'z') {//e的大小在a-z
            locate = FindLocate(L, e);//有序链表，所以找出适合它大小的位置
            ListInsert(L, locate, e);//插入到线性表中特定位置
        }
    }
};
```

把元素插入表中，如果存在重复则不差入

```c++
bool ListInsert(LinkList &L, int locate, char e) {
    LinkNodePtr q;//指针
    q = L.head->next;//指向第一个节点
    for(int i = 1; i < locate - 1; i++) {//直到指向locate - 1节点
       q = q->next;//指针往后指
    }
    if(q->next != NULL && e == q->next->data) {//如果第locate位置的值等于e，则直接return
        return false;
    }
    else {
        LinkNodePtr p;//指针
        p = (LinkNodePtr)malloc(sizeof(LinkNode));//申请一个节点
        p->data = e;
        p->next = q->next;
        q->next = p;//在locate位置插入p
        L.len++;
        return true;    
    }
};
```

打印出一个集合

```c++
void ListTraverse(LinkList &L) {
    LinkNodePtr p;//一个节点指针
    p = L.head->next;//指向第一个节点
    for(; p != NULL;) {
        cout<<p->data;//打印数据
        p = p->next;//指针往后指
    }
    cout<<endl;
};
```

获取特定位置的元素

```c++
void GetElem(LinkList &L, int i, char &e) {
    LinkNodePtr p;//一个节点指针
    p = L.head->next;//指向第一个节点
    int j = 1;
    for(; j < i; j++) {//获取第i个节点的值
        p = p->next;//指针往后指
    }
    e = p->data;
};
```

把元素推入L中

```c++
bool ListAppend(LinkList &L, char e) {
    LinkNodePtr p;
    p = (LinkNodePtr)malloc(sizeof(LinkNode));
    p->data = e;
    L.tail->next = p;//往链表尾部加元素
    L.tail = p;//把尾指针指向最后一个元素
    L.tail->next = NULL;
    L.len++;
    return true;
};
```

求减集

```c++
void Reduce(LinkList &La, LinkList &Lb, LinkList &Lc) {
    int aLen = La.len;
    int bLen = Lb.len;
    bool equal;
    char ae;
    char be;
    for(int i = 1; i <= aLen; i++) {
        GetElem(La, i, ae);//获取La的元素
        for(int j = 1; j <= bLen; j++) {
            GetElem(Lb, j, be);//获取Lb的元素
            equal = Equal(ae, be);
            if(equal)
                break;//一遇到一样的马上退出
        }
        if(!equal) {
            ListAppend(Lc, ae);//La中与Lb中不一样的进入Lc
        }
    }
};
```

![](/img/reduceset.png)

求并集函数

```c++
void Sum(LinkList &La, LinkList &Lb, LinkList &Lc) {
    int aLen = La.len;
    int bLen = Lb.len;
    for(int i = 1; i <= aLen; i++) {
        char e;
        GetElem(La, i, e);
        ListAppend(Lc, e);//先把La中的元素都放进Lc
    }
    for(int i = 1; i <= bLen; i++) {
        int locate;
        char e;
        GetElem(Lb, i, e);
        locate = FindLocate(Lc, e);
        ListInsert(Lc, locate, e);//然后把Lb中的元素插进，在ListInsert函数内部中判断重复
    }
};
```

求交集函数

```c++
void Intersection(LinkList &La, LinkList &Lb, LinkList &Lc) {
    int aLen = La.len;
    int bLen = Lb.len;
    bool equal;
    char ae;
    char be;
    for(int i = 1; i <= aLen; i++) {
        GetElem(La, i, ae);//取La的元素
        for(int j = 1; j <= bLen; j++) {
            GetElem(Lb, j, be);//取Lb的元素
            equal = Equal(ae, be);//判断他们是否相等
            if(equal) {//相等则压入线性表Lc中
                ListAppend(Lc, ae);
                break;                
            }
        }
    }
};
```