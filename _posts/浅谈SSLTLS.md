---
title: 浅谈SSL/TLS
date: 2017-11-07 19:36:45
tags: SSL/TLS
---

## 序言

在网络中，数据在服务器端和客户端之间传递，由于是明文传递的内容，一旦网络被人监控，数据就可能一览无余地展现在中间的窃听者面前。为此我们需要将数据加密后再进行网络传输，这样即使数据被截获和窃听，窃听者也无法知道数据的真实内容是什么。但是对于我们的应用层协议而言，如HTTP、FTP等，我们仍然希望能够透明地处理地处理数据，而无须操心网络传输过程中的安全问题。SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。最初的SSL应用层在Web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称TLS(Transport Layer Security，安全传输层协议)。

<!--more-->

## TLS/SSL

### 密匙

TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥。客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要客户端的公钥进行加密，如此才能完成加密解密的过程，如下图:

![](/img/ssltls.png)

公私钥的非对称加密虽然好，但是网络中依然可能存在窃听的情况，典型的例子是中间人攻击。客户端和服务器端在交换公钥的过程中，中间人对客户端扮演服务器端的角色，对服务器端扮演客户端的角色，因此客户端和服务器端几乎感受不到中间人的存在。为了解决这种问题，数据传输过程中还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器。如果不能保证这种认证，中间人可能会将伪造的站点响应给用户，从而造成经济损失。中间人攻击示意图:

![](/img/attack.png)

为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数据证书包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。

### 数字证书

为了确保我们的数据安全，现在我们引入了一个第三方: CA(Certificate Authority, 数字证书认证中心)。CA的作用是为站点颁布证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名。

为了得到签名证书，服务器端需要通过自己的私钥生成CSR(Certificate Signing Request，证书签名请求)文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构就能验证证书是否合法。

通过CA机构颁发证书通常是一个繁琐的过程，需要付出一定的费力和精力。

![](/img/checkca.png)

CA机构将证书颁发给服务器端后，证书在请求的过程中会被发送给客户端，客户端需要通过CA的证书验证真伪。如果是知名的CA机构，它们的证书一般预装在浏览器中。

### SSL作用

- 所有信息都是加密传播，第三方无法窃听。
- 具有校验机制，一旦被篡改，通信双方会立刻发现。
- 配备身份证书，防止身份被冒充。

### TLS/SSL协议的组成

![](/img/TLSdetail.jpg)

TLS/SSL协议又可以分为两层，上层分为三个子协议: HandShake，ChangeCiperSpec，Alert，下层为Recode。

### SSL基本的运行机制

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

#### 公钥加密计算量太大，如何减少耗用的时间？

解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。

> 对称加密: 同一个密钥可以同时用作信息的加密和解密。
> 非对称加密: 需要两个密钥：公开密钥（publickey）和私有密钥（privatekey），如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。

SSL/TLS协议的基本过程是这样的：

- 客户端向服务器端索要并验证公钥。
- 双方协商生成"对话密钥"。
- 双方采用"对话密钥"进行加密通信。

上面过程的前两步，又称为"握手阶段"（handshake）。

### TLS/SSL协议的握手过程

HTTPS通信建立的过程其实是这样子的: 首先完成TCP三次握手，再进行TLS/SSL握手，以上两类握手完成后就建立了一个安全的通道，最后才进行HTTP通讯。

五步握手: 

1. TLS/SSL客户端会发送一个成为“Client Hello”的消息包，里面包含了一串随机字符串（Client random）、SSL/TLS的版本和客户端支持的已经按优先次序排列的密码族。
2. TLS/SSL服务器这边也会响应一个“Server Hello”的消息包，里面包含了一串随机字符串（Server random）、服务器选择的加密方式、服务器的数字证书、以及session ID。
3. TLS/SSL客户端先是核实了服务器的数字证书后，使用服务器提供的公钥加密一串预主密钥(premaster secret)发送给服务器。
4. TLS/SSL服务器使用自己的密钥解密获取预主密钥(premaster key)。
5. 最后双方根据前面的协商好的加密方式，结合两串随机字符串(Client random, Server random)和预主密钥(premaster key)生成后续应用层通信使用的会话秘钥，至此完成了安全通道的建立，后续的消息通讯可以使用这个会话秘钥加密进行。
![](http://image.beekka.com/blog/2014/bg2014092003.png)

抓包看看，如下图:

Client Hello包:

![](/img/SSLdetail.png)

Server Hello包:

![](/img/ServerHello.png)

抓到的TLS包:

![](/img/packets.png)

### 私钥的作用

- 生成对话密钥一共需要三个随机数。
- 握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
- 服务器公钥放在服务器的数字证书之中。

从上面第二点可知，整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。这就是CloudFlare能够提供Keyless服务的根本原因。

某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。

![](http://image.beekka.com/blog/2014/bg2014092005.png)

上图中，银行的服务器只参与第四步，后面的对话都不再会用到私钥了。

### DH算法的握手阶段

整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。

虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的RSA算法，改为 Diffie-Hellman算法（简称DH算法）。

采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。

![](http://image.beekka.com/blog/2014/bg2014092007.png)

上图中，第三步和第四步由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。

### session的恢复

握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。

这时有两种方法可以恢复原来的session：一种叫做session ID，另一种叫做session ticket。

session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。

![](http://image.beekka.com/blog/2014/bg2014092009.png)

session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。

![](http://image.beekka.com/blog/2014/bg2014092011.png)

上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。